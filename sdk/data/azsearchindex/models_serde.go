// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azsearchindex

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AutocompleteItem.
func (a AutocompleteItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "queryPlusText", a.QueryPlusText)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutocompleteItem.
func (a *AutocompleteItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "queryPlusText":
				err = unpopulate(val, "QueryPlusText", &a.QueryPlusText)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutocompleteRequest.
func (a AutocompleteRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autocompleteMode", a.AutocompleteMode)
	populate(objectMap, "filter", a.Filter)
	populate(objectMap, "highlightPostTag", a.HighlightPostTag)
	populate(objectMap, "highlightPreTag", a.HighlightPreTag)
	populate(objectMap, "minimumCoverage", a.MinimumCoverage)
	populate(objectMap, "searchFields", a.SearchFields)
	populate(objectMap, "search", a.SearchText)
	populate(objectMap, "suggesterName", a.SuggesterName)
	populate(objectMap, "top", a.Top)
	populate(objectMap, "fuzzy", a.UseFuzzyMatching)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutocompleteRequest.
func (a *AutocompleteRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autocompleteMode":
				err = unpopulate(val, "AutocompleteMode", &a.AutocompleteMode)
			delete(rawMsg, key)
		case "filter":
				err = unpopulate(val, "Filter", &a.Filter)
			delete(rawMsg, key)
		case "highlightPostTag":
				err = unpopulate(val, "HighlightPostTag", &a.HighlightPostTag)
			delete(rawMsg, key)
		case "highlightPreTag":
				err = unpopulate(val, "HighlightPreTag", &a.HighlightPreTag)
			delete(rawMsg, key)
		case "minimumCoverage":
				err = unpopulate(val, "MinimumCoverage", &a.MinimumCoverage)
			delete(rawMsg, key)
		case "searchFields":
				err = unpopulate(val, "SearchFields", &a.SearchFields)
			delete(rawMsg, key)
		case "search":
				err = unpopulate(val, "SearchText", &a.SearchText)
			delete(rawMsg, key)
		case "suggesterName":
				err = unpopulate(val, "SuggesterName", &a.SuggesterName)
			delete(rawMsg, key)
		case "top":
				err = unpopulate(val, "Top", &a.Top)
			delete(rawMsg, key)
		case "fuzzy":
				err = unpopulate(val, "UseFuzzyMatching", &a.UseFuzzyMatching)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutocompleteResult.
func (a AutocompleteResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.coverage", a.Coverage)
	populate(objectMap, "value", a.Results)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutocompleteResult.
func (a *AutocompleteResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.coverage":
				err = unpopulate(val, "Coverage", &a.Coverage)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Results", &a.Results)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FacetResult.
func (f FacetResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", f.Count)
	if f.AdditionalProperties != nil {
		for key, val := range f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FacetResult.
func (f *FacetResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
				err = unpopulate(val, "Count", &f.Count)
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				f.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexAction.
func (i IndexAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.action", i.ActionType)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexAction.
func (i *IndexAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.action":
				err = unpopulate(val, "ActionType", &i.ActionType)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexBatch.
func (i IndexBatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", i.Actions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexBatch.
func (i *IndexBatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Actions", &i.Actions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexDocumentsResult.
func (i IndexDocumentsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", i.Results)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexDocumentsResult.
func (i *IndexDocumentsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Results", &i.Results)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexingResult.
func (i IndexingResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorMessage", i.ErrorMessage)
	populate(objectMap, "key", i.Key)
	populate(objectMap, "statusCode", i.StatusCode)
	populate(objectMap, "status", i.Succeeded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexingResult.
func (i *IndexingResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
				err = unpopulate(val, "ErrorMessage", &i.ErrorMessage)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &i.Key)
			delete(rawMsg, key)
		case "statusCode":
				err = unpopulate(val, "StatusCode", &i.StatusCode)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Succeeded", &i.Succeeded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueryAnswerResult.
func (q QueryAnswerResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "highlights", q.Highlights)
	populate(objectMap, "key", q.Key)
	populate(objectMap, "score", q.Score)
	populate(objectMap, "text", q.Text)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueryAnswerResult.
func (q *QueryAnswerResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "highlights":
				err = unpopulate(val, "Highlights", &q.Highlights)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &q.Key)
			delete(rawMsg, key)
		case "score":
				err = unpopulate(val, "Score", &q.Score)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &q.Text)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueryCaptionResult.
func (q QueryCaptionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "highlights", q.Highlights)
	populate(objectMap, "text", q.Text)
	if q.AdditionalProperties != nil {
		for key, val := range q.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueryCaptionResult.
func (q *QueryCaptionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "highlights":
				err = unpopulate(val, "Highlights", &q.Highlights)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &q.Text)
			delete(rawMsg, key)
		default:
			if q.AdditionalProperties == nil {
				q.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				q.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SearchDocumentsResult.
func (s SearchDocumentsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.answers", s.Answers)
	populate(objectMap, "@odata.count", s.Count)
	populate(objectMap, "@search.coverage", s.Coverage)
	populate(objectMap, "@search.facets", s.Facets)
	populate(objectMap, "@odata.nextLink", s.NextLink)
	populate(objectMap, "@search.nextPageParameters", s.NextPageParameters)
	populate(objectMap, "value", s.Results)
	populate(objectMap, "@search.semanticPartialResponseReason", s.SemanticPartialResponseReason)
	populate(objectMap, "@search.semanticPartialResponseType", s.SemanticPartialResponseType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SearchDocumentsResult.
func (s *SearchDocumentsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.answers":
				err = unpopulate(val, "Answers", &s.Answers)
			delete(rawMsg, key)
		case "@odata.count":
				err = unpopulate(val, "Count", &s.Count)
			delete(rawMsg, key)
		case "@search.coverage":
				err = unpopulate(val, "Coverage", &s.Coverage)
			delete(rawMsg, key)
		case "@search.facets":
				err = unpopulate(val, "Facets", &s.Facets)
			delete(rawMsg, key)
		case "@odata.nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "@search.nextPageParameters":
				err = unpopulate(val, "NextPageParameters", &s.NextPageParameters)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Results", &s.Results)
			delete(rawMsg, key)
		case "@search.semanticPartialResponseReason":
				err = unpopulate(val, "SemanticPartialResponseReason", &s.SemanticPartialResponseReason)
			delete(rawMsg, key)
		case "@search.semanticPartialResponseType":
				err = unpopulate(val, "SemanticPartialResponseType", &s.SemanticPartialResponseType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SearchRequest.
func (s SearchRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "answers", s.Answers)
	populate(objectMap, "captions", s.Captions)
	populate(objectMap, "facets", s.Facets)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "highlight", s.HighlightFields)
	populate(objectMap, "highlightPostTag", s.HighlightPostTag)
	populate(objectMap, "highlightPreTag", s.HighlightPreTag)
	populate(objectMap, "count", s.IncludeTotalResultCount)
	populate(objectMap, "minimumCoverage", s.MinimumCoverage)
	populate(objectMap, "orderby", s.OrderBy)
	populate(objectMap, "queryType", s.QueryType)
	populate(objectMap, "scoringParameters", s.ScoringParameters)
	populate(objectMap, "scoringProfile", s.ScoringProfile)
	populate(objectMap, "scoringStatistics", s.ScoringStatistics)
	populate(objectMap, "searchFields", s.SearchFields)
	populate(objectMap, "searchMode", s.SearchMode)
	populate(objectMap, "search", s.SearchText)
	populate(objectMap, "select", s.Select)
	populate(objectMap, "semanticConfiguration", s.SemanticConfiguration)
	populate(objectMap, "semanticErrorHandling", s.SemanticErrorHandling)
	populate(objectMap, "semanticMaxWaitInMilliseconds", s.SemanticMaxWaitInMilliseconds)
	populate(objectMap, "semanticQuery", s.SemanticQuery)
	populate(objectMap, "sessionId", s.SessionID)
	populate(objectMap, "skip", s.Skip)
	populate(objectMap, "top", s.Top)
	populate(objectMap, "vectorFilterMode", s.VectorFilterMode)
	populate(objectMap, "vectorQueries", s.VectorQueries)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SearchRequest.
func (s *SearchRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "answers":
				err = unpopulate(val, "Answers", &s.Answers)
			delete(rawMsg, key)
		case "captions":
				err = unpopulate(val, "Captions", &s.Captions)
			delete(rawMsg, key)
		case "facets":
				err = unpopulate(val, "Facets", &s.Facets)
			delete(rawMsg, key)
		case "filter":
				err = unpopulate(val, "Filter", &s.Filter)
			delete(rawMsg, key)
		case "highlight":
				err = unpopulate(val, "HighlightFields", &s.HighlightFields)
			delete(rawMsg, key)
		case "highlightPostTag":
				err = unpopulate(val, "HighlightPostTag", &s.HighlightPostTag)
			delete(rawMsg, key)
		case "highlightPreTag":
				err = unpopulate(val, "HighlightPreTag", &s.HighlightPreTag)
			delete(rawMsg, key)
		case "count":
				err = unpopulate(val, "IncludeTotalResultCount", &s.IncludeTotalResultCount)
			delete(rawMsg, key)
		case "minimumCoverage":
				err = unpopulate(val, "MinimumCoverage", &s.MinimumCoverage)
			delete(rawMsg, key)
		case "orderby":
				err = unpopulate(val, "OrderBy", &s.OrderBy)
			delete(rawMsg, key)
		case "queryType":
				err = unpopulate(val, "QueryType", &s.QueryType)
			delete(rawMsg, key)
		case "scoringParameters":
				err = unpopulate(val, "ScoringParameters", &s.ScoringParameters)
			delete(rawMsg, key)
		case "scoringProfile":
				err = unpopulate(val, "ScoringProfile", &s.ScoringProfile)
			delete(rawMsg, key)
		case "scoringStatistics":
				err = unpopulate(val, "ScoringStatistics", &s.ScoringStatistics)
			delete(rawMsg, key)
		case "searchFields":
				err = unpopulate(val, "SearchFields", &s.SearchFields)
			delete(rawMsg, key)
		case "searchMode":
				err = unpopulate(val, "SearchMode", &s.SearchMode)
			delete(rawMsg, key)
		case "search":
				err = unpopulate(val, "SearchText", &s.SearchText)
			delete(rawMsg, key)
		case "select":
				err = unpopulate(val, "Select", &s.Select)
			delete(rawMsg, key)
		case "semanticConfiguration":
				err = unpopulate(val, "SemanticConfiguration", &s.SemanticConfiguration)
			delete(rawMsg, key)
		case "semanticErrorHandling":
				err = unpopulate(val, "SemanticErrorHandling", &s.SemanticErrorHandling)
			delete(rawMsg, key)
		case "semanticMaxWaitInMilliseconds":
				err = unpopulate(val, "SemanticMaxWaitInMilliseconds", &s.SemanticMaxWaitInMilliseconds)
			delete(rawMsg, key)
		case "semanticQuery":
				err = unpopulate(val, "SemanticQuery", &s.SemanticQuery)
			delete(rawMsg, key)
		case "sessionId":
				err = unpopulate(val, "SessionID", &s.SessionID)
			delete(rawMsg, key)
		case "skip":
				err = unpopulate(val, "Skip", &s.Skip)
			delete(rawMsg, key)
		case "top":
				err = unpopulate(val, "Top", &s.Top)
			delete(rawMsg, key)
		case "vectorFilterMode":
				err = unpopulate(val, "VectorFilterMode", &s.VectorFilterMode)
			delete(rawMsg, key)
		case "vectorQueries":
			s.VectorQueries, err = unmarshalVectorQueryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SearchResult.
func (s SearchResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.captions", s.Captions)
	populate(objectMap, "@search.highlights", s.Highlights)
	populate(objectMap, "@search.rerankerScore", s.RerankerScore)
	populate(objectMap, "@search.score", s.Score)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SearchResult.
func (s *SearchResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.captions":
				err = unpopulate(val, "Captions", &s.Captions)
			delete(rawMsg, key)
		case "@search.highlights":
				err = unpopulate(val, "Highlights", &s.Highlights)
			delete(rawMsg, key)
		case "@search.rerankerScore":
				err = unpopulate(val, "RerankerScore", &s.RerankerScore)
			delete(rawMsg, key)
		case "@search.score":
				err = unpopulate(val, "Score", &s.Score)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuggestDocumentsResult.
func (s SuggestDocumentsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.coverage", s.Coverage)
	populate(objectMap, "value", s.Results)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SuggestDocumentsResult.
func (s *SuggestDocumentsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.coverage":
				err = unpopulate(val, "Coverage", &s.Coverage)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Results", &s.Results)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuggestRequest.
func (s SuggestRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "filter", s.Filter)
	populate(objectMap, "highlightPostTag", s.HighlightPostTag)
	populate(objectMap, "highlightPreTag", s.HighlightPreTag)
	populate(objectMap, "minimumCoverage", s.MinimumCoverage)
	populate(objectMap, "orderby", s.OrderBy)
	populate(objectMap, "searchFields", s.SearchFields)
	populate(objectMap, "search", s.SearchText)
	populate(objectMap, "select", s.Select)
	populate(objectMap, "suggesterName", s.SuggesterName)
	populate(objectMap, "top", s.Top)
	populate(objectMap, "fuzzy", s.UseFuzzyMatching)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SuggestRequest.
func (s *SuggestRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filter":
				err = unpopulate(val, "Filter", &s.Filter)
			delete(rawMsg, key)
		case "highlightPostTag":
				err = unpopulate(val, "HighlightPostTag", &s.HighlightPostTag)
			delete(rawMsg, key)
		case "highlightPreTag":
				err = unpopulate(val, "HighlightPreTag", &s.HighlightPreTag)
			delete(rawMsg, key)
		case "minimumCoverage":
				err = unpopulate(val, "MinimumCoverage", &s.MinimumCoverage)
			delete(rawMsg, key)
		case "orderby":
				err = unpopulate(val, "OrderBy", &s.OrderBy)
			delete(rawMsg, key)
		case "searchFields":
				err = unpopulate(val, "SearchFields", &s.SearchFields)
			delete(rawMsg, key)
		case "search":
				err = unpopulate(val, "SearchText", &s.SearchText)
			delete(rawMsg, key)
		case "select":
				err = unpopulate(val, "Select", &s.Select)
			delete(rawMsg, key)
		case "suggesterName":
				err = unpopulate(val, "SuggesterName", &s.SuggesterName)
			delete(rawMsg, key)
		case "top":
				err = unpopulate(val, "Top", &s.Top)
			delete(rawMsg, key)
		case "fuzzy":
				err = unpopulate(val, "UseFuzzyMatching", &s.UseFuzzyMatching)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuggestResult.
func (s SuggestResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@search.text", s.Text)
	if s.AdditionalProperties != nil {
		for key, val := range s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SuggestResult.
func (s *SuggestResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@search.text":
				err = unpopulate(val, "Text", &s.Text)
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				s.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorQuery.
func (v VectorQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exhaustive", v.Exhaustive)
	populate(objectMap, "fields", v.Fields)
	populate(objectMap, "k", v.K)
	objectMap["kind"] = v.Kind
	populate(objectMap, "oversampling", v.Oversampling)
	populate(objectMap, "weight", v.Weight)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorQuery.
func (v *VectorQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exhaustive":
				err = unpopulate(val, "Exhaustive", &v.Exhaustive)
			delete(rawMsg, key)
		case "fields":
				err = unpopulate(val, "Fields", &v.Fields)
			delete(rawMsg, key)
		case "k":
				err = unpopulate(val, "K", &v.K)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "oversampling":
				err = unpopulate(val, "Oversampling", &v.Oversampling)
			delete(rawMsg, key)
		case "weight":
				err = unpopulate(val, "Weight", &v.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorizableTextQuery.
func (v VectorizableTextQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exhaustive", v.Exhaustive)
	populate(objectMap, "fields", v.Fields)
	populate(objectMap, "k", v.K)
	objectMap["kind"] = VectorQueryKindText
	populate(objectMap, "oversampling", v.Oversampling)
	populate(objectMap, "text", v.Text)
	populate(objectMap, "weight", v.Weight)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorizableTextQuery.
func (v *VectorizableTextQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exhaustive":
				err = unpopulate(val, "Exhaustive", &v.Exhaustive)
			delete(rawMsg, key)
		case "fields":
				err = unpopulate(val, "Fields", &v.Fields)
			delete(rawMsg, key)
		case "k":
				err = unpopulate(val, "K", &v.K)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "oversampling":
				err = unpopulate(val, "Oversampling", &v.Oversampling)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &v.Text)
			delete(rawMsg, key)
		case "weight":
				err = unpopulate(val, "Weight", &v.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorizedQuery.
func (v VectorizedQuery) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exhaustive", v.Exhaustive)
	populate(objectMap, "fields", v.Fields)
	populate(objectMap, "k", v.K)
	objectMap["kind"] = VectorQueryKindVector
	populate(objectMap, "oversampling", v.Oversampling)
	populate(objectMap, "vector", v.Vector)
	populate(objectMap, "weight", v.Weight)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorizedQuery.
func (v *VectorizedQuery) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exhaustive":
				err = unpopulate(val, "Exhaustive", &v.Exhaustive)
			delete(rawMsg, key)
		case "fields":
				err = unpopulate(val, "Fields", &v.Fields)
			delete(rawMsg, key)
		case "k":
				err = unpopulate(val, "K", &v.K)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "oversampling":
				err = unpopulate(val, "Oversampling", &v.Oversampling)
			delete(rawMsg, key)
		case "vector":
				err = unpopulate(val, "Vector", &v.Vector)
			delete(rawMsg, key)
		case "weight":
				err = unpopulate(val, "Weight", &v.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

