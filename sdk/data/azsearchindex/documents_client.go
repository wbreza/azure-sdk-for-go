// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azsearchindex

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// DocumentsClient contains the methods for the Documents group.
// Don't use this type directly, use a constructor function instead.
type DocumentsClient struct {
	internal *azcore.Client
	endpoint string
	indexName string
}

// AutocompleteGet - Autocompletes incomplete query terms based on input text and matching terms in the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - searchText - The incomplete term which should be auto-completed.
//   - suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - AutocompleteOptions - AutocompleteOptions contains a group of parameters for the DocumentsClient.AutocompleteGet method.
//   - options - DocumentsClientAutocompleteGetOptions contains the optional parameters for the DocumentsClient.AutocompleteGet
//     method.
func (client *DocumentsClient) AutocompleteGet(ctx context.Context, searchText string, suggesterName string, requestOptions *RequestOptions, autocompleteOptions *AutocompleteOptions, options *DocumentsClientAutocompleteGetOptions) (DocumentsClientAutocompleteGetResponse, error) {
	var err error
	req, err := client.autocompleteGetCreateRequest(ctx, searchText, suggesterName, requestOptions, autocompleteOptions, options)
	if err != nil {
		return DocumentsClientAutocompleteGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientAutocompleteGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientAutocompleteGetResponse{}, err
	}
	resp, err := client.autocompleteGetHandleResponse(httpResp)
	return resp, err
}

// autocompleteGetCreateRequest creates the AutocompleteGet request.
func (client *DocumentsClient) autocompleteGetCreateRequest(ctx context.Context, searchText string, suggesterName string, requestOptions *RequestOptions, autocompleteOptions *AutocompleteOptions, _ *DocumentsClientAutocompleteGetOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.autocomplete"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if autocompleteOptions != nil && autocompleteOptions.Filter != nil {
		reqQP.Set("$filter", *autocompleteOptions.Filter)
	}
	if autocompleteOptions != nil && autocompleteOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*autocompleteOptions.Top), 10))
	}
	reqQP.Set("api-version", "2024-07-01")
	if autocompleteOptions != nil && autocompleteOptions.AutocompleteMode != nil {
		reqQP.Set("autocompleteMode", string(*autocompleteOptions.AutocompleteMode))
	}
	if autocompleteOptions != nil && autocompleteOptions.UseFuzzyMatching != nil {
		reqQP.Set("fuzzy", strconv.FormatBool(*autocompleteOptions.UseFuzzyMatching))
	}
	if autocompleteOptions != nil && autocompleteOptions.HighlightPostTag != nil {
		reqQP.Set("highlightPostTag", *autocompleteOptions.HighlightPostTag)
	}
	if autocompleteOptions != nil && autocompleteOptions.HighlightPreTag != nil {
		reqQP.Set("highlightPreTag", *autocompleteOptions.HighlightPreTag)
	}
	if autocompleteOptions != nil && autocompleteOptions.MinimumCoverage != nil {
		reqQP.Set("minimumCoverage", strconv.FormatFloat(*autocompleteOptions.MinimumCoverage, 'f', -1, 64))
	}
	reqQP.Set("search", searchText)
	if autocompleteOptions != nil && autocompleteOptions.SearchFields != nil {
		reqQP.Set("searchFields", strings.Join(autocompleteOptions.SearchFields, ","))
	}
	reqQP.Set("suggesterName", suggesterName)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	return req, nil
}

// autocompleteGetHandleResponse handles the AutocompleteGet response.
func (client *DocumentsClient) autocompleteGetHandleResponse(resp *http.Response) (DocumentsClientAutocompleteGetResponse, error) {
	result := DocumentsClientAutocompleteGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AutocompleteResult); err != nil {
		return DocumentsClientAutocompleteGetResponse{}, err
	}
	return result, nil
}

// AutocompletePost - Autocompletes incomplete query terms based on input text and matching terms in the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - autocompleteRequest - The definition of the Autocomplete request.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientAutocompletePostOptions contains the optional parameters for the DocumentsClient.AutocompletePost
//     method.
func (client *DocumentsClient) AutocompletePost(ctx context.Context, autocompleteRequest AutocompleteRequest, requestOptions *RequestOptions, options *DocumentsClientAutocompletePostOptions) (DocumentsClientAutocompletePostResponse, error) {
	var err error
	req, err := client.autocompletePostCreateRequest(ctx, autocompleteRequest, requestOptions, options)
	if err != nil {
		return DocumentsClientAutocompletePostResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientAutocompletePostResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientAutocompletePostResponse{}, err
	}
	resp, err := client.autocompletePostHandleResponse(httpResp)
	return resp, err
}

// autocompletePostCreateRequest creates the AutocompletePost request.
func (client *DocumentsClient) autocompletePostCreateRequest(ctx context.Context, autocompleteRequest AutocompleteRequest, requestOptions *RequestOptions, _ *DocumentsClientAutocompletePostOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.post.autocomplete"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	if err := runtime.MarshalAsJSON(req, autocompleteRequest); err != nil {
	return nil, err
}
	return req, nil
}

// autocompletePostHandleResponse handles the AutocompletePost response.
func (client *DocumentsClient) autocompletePostHandleResponse(resp *http.Response) (DocumentsClientAutocompletePostResponse, error) {
	result := DocumentsClientAutocompletePostResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AutocompleteResult); err != nil {
		return DocumentsClientAutocompletePostResponse{}, err
	}
	return result, nil
}

// Count - Queries the number of documents in the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientCountOptions contains the optional parameters for the DocumentsClient.Count method.
func (client *DocumentsClient) Count(ctx context.Context, requestOptions *RequestOptions, options *DocumentsClientCountOptions) (DocumentsClientCountResponse, error) {
	var err error
	req, err := client.countCreateRequest(ctx, requestOptions, options)
	if err != nil {
		return DocumentsClientCountResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientCountResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientCountResponse{}, err
	}
	resp, err := client.countHandleResponse(httpResp)
	return resp, err
}

// countCreateRequest creates the Count request.
func (client *DocumentsClient) countCreateRequest(ctx context.Context, requestOptions *RequestOptions, _ *DocumentsClientCountOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/$count"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	return req, nil
}

// countHandleResponse handles the Count response.
func (client *DocumentsClient) countHandleResponse(resp *http.Response) (DocumentsClientCountResponse, error) {
	result := DocumentsClientCountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DocumentsClientCountResponse{}, err
	}
	return result, nil
}

// Get - Retrieves a document from the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - key - The key of the document to retrieve.
//   - options - DocumentsClientGetOptions contains the optional parameters for the DocumentsClient.Get method.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
func (client *DocumentsClient) Get(ctx context.Context, key string, options *DocumentsClientGetOptions, requestOptions *RequestOptions) (DocumentsClientGetResponse, error) {
	var err error
	req, err := client.getCreateRequest(ctx, key, options, requestOptions)
	if err != nil {
		return DocumentsClientGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientGetResponse{}, err
	}
	resp, err := client.getHandleResponse(httpResp)
	return resp, err
}

// getCreateRequest creates the Get request.
func (client *DocumentsClient) getCreateRequest(ctx context.Context, key string, options *DocumentsClientGetOptions, requestOptions *RequestOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs('{key}')"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectedFields != nil {
		reqQP.Set("$select", strings.Join(options.SelectedFields, ","))
	}
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *DocumentsClient) getHandleResponse(resp *http.Response) (DocumentsClientGetResponse, error) {
	result := DocumentsClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DocumentsClientGetResponse{}, err
	}
	return result, nil
}

// Index - Sends a batch of document write actions to the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - batch - The batch of index actions.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientIndexOptions contains the optional parameters for the DocumentsClient.Index method.
func (client *DocumentsClient) Index(ctx context.Context, batch IndexBatch, requestOptions *RequestOptions, options *DocumentsClientIndexOptions) (DocumentsClientIndexResponse, error) {
	var err error
	req, err := client.indexCreateRequest(ctx, batch, requestOptions, options)
	if err != nil {
		return DocumentsClientIndexResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientIndexResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusMultiStatus) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientIndexResponse{}, err
	}
	resp, err := client.indexHandleResponse(httpResp)
	return resp, err
}

// indexCreateRequest creates the Index request.
func (client *DocumentsClient) indexCreateRequest(ctx context.Context, batch IndexBatch, requestOptions *RequestOptions, _ *DocumentsClientIndexOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.index"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	if err := runtime.MarshalAsJSON(req, batch); err != nil {
	return nil, err
}
	return req, nil
}

// indexHandleResponse handles the Index response.
func (client *DocumentsClient) indexHandleResponse(resp *http.Response) (DocumentsClientIndexResponse, error) {
	result := DocumentsClientIndexResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IndexDocumentsResult); err != nil {
		return DocumentsClientIndexResponse{}, err
	}
	return result, nil
}

// SearchGet - Searches for documents in the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - options - DocumentsClientSearchGetOptions contains the optional parameters for the DocumentsClient.SearchGet method.
//   - SearchOptions - SearchOptions contains a group of parameters for the DocumentsClient.SearchGet method.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
func (client *DocumentsClient) SearchGet(ctx context.Context, options *DocumentsClientSearchGetOptions, searchOptions *SearchOptions, requestOptions *RequestOptions) (DocumentsClientSearchGetResponse, error) {
	var err error
	req, err := client.searchGetCreateRequest(ctx, options, searchOptions, requestOptions)
	if err != nil {
		return DocumentsClientSearchGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientSearchGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientSearchGetResponse{}, err
	}
	resp, err := client.searchGetHandleResponse(httpResp)
	return resp, err
}

// searchGetCreateRequest creates the SearchGet request.
func (client *DocumentsClient) searchGetCreateRequest(ctx context.Context, options *DocumentsClientSearchGetOptions, searchOptions *SearchOptions, requestOptions *RequestOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if searchOptions != nil && searchOptions.IncludeTotalResultCount != nil {
		reqQP.Set("$count", strconv.FormatBool(*searchOptions.IncludeTotalResultCount))
	}
	if searchOptions != nil && searchOptions.Filter != nil {
		reqQP.Set("$filter", *searchOptions.Filter)
	}
	if searchOptions != nil && searchOptions.OrderBy != nil {
		reqQP.Set("$orderby", strings.Join(searchOptions.OrderBy, ","))
	}
	if searchOptions != nil && searchOptions.Select != nil {
		reqQP.Set("$select", strings.Join(searchOptions.Select, ","))
	}
	if searchOptions != nil && searchOptions.Skip != nil {
		reqQP.Set("$skip", strconv.FormatInt(int64(*searchOptions.Skip), 10))
	}
	if searchOptions != nil && searchOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*searchOptions.Top), 10))
	}
	if searchOptions != nil && searchOptions.Answers != nil {
		reqQP.Set("answers", string(*searchOptions.Answers))
	}
	reqQP.Set("api-version", "2024-07-01")
	if searchOptions != nil && searchOptions.Captions != nil {
		reqQP.Set("captions", string(*searchOptions.Captions))
	}
	if searchOptions != nil && searchOptions.Facets != nil {
			for _, qv := range searchOptions.Facets {
		reqQP.Add("facet", qv)
	}
	}
	if searchOptions != nil && searchOptions.HighlightFields != nil {
		reqQP.Set("highlight", strings.Join(searchOptions.HighlightFields, ","))
	}
	if searchOptions != nil && searchOptions.HighlightPostTag != nil {
		reqQP.Set("highlightPostTag", *searchOptions.HighlightPostTag)
	}
	if searchOptions != nil && searchOptions.HighlightPreTag != nil {
		reqQP.Set("highlightPreTag", *searchOptions.HighlightPreTag)
	}
	if searchOptions != nil && searchOptions.MinimumCoverage != nil {
		reqQP.Set("minimumCoverage", strconv.FormatFloat(*searchOptions.MinimumCoverage, 'f', -1, 64))
	}
	if searchOptions != nil && searchOptions.QueryType != nil {
		reqQP.Set("queryType", string(*searchOptions.QueryType))
	}
	if searchOptions != nil && searchOptions.ScoringParameters != nil {
			for _, qv := range searchOptions.ScoringParameters {
		reqQP.Add("scoringParameter", qv)
	}
	}
	if searchOptions != nil && searchOptions.ScoringProfile != nil {
		reqQP.Set("scoringProfile", *searchOptions.ScoringProfile)
	}
	if searchOptions != nil && searchOptions.ScoringStatistics != nil {
		reqQP.Set("scoringStatistics", string(*searchOptions.ScoringStatistics))
	}
	if options != nil && options.SearchText != nil {
		reqQP.Set("search", *options.SearchText)
	}
	if searchOptions != nil && searchOptions.SearchFields != nil {
		reqQP.Set("searchFields", strings.Join(searchOptions.SearchFields, ","))
	}
	if searchOptions != nil && searchOptions.SearchMode != nil {
		reqQP.Set("searchMode", string(*searchOptions.SearchMode))
	}
	if searchOptions != nil && searchOptions.SemanticConfiguration != nil {
		reqQP.Set("semanticConfiguration", *searchOptions.SemanticConfiguration)
	}
	if searchOptions != nil && searchOptions.SemanticErrorHandling != nil {
		reqQP.Set("semanticErrorHandling", string(*searchOptions.SemanticErrorHandling))
	}
	if searchOptions != nil && searchOptions.SemanticMaxWaitInMilliseconds != nil {
		reqQP.Set("semanticMaxWaitInMilliseconds", strconv.FormatInt(int64(*searchOptions.SemanticMaxWaitInMilliseconds), 10))
	}
	if searchOptions != nil && searchOptions.SemanticQuery != nil {
		reqQP.Set("semanticQuery", *searchOptions.SemanticQuery)
	}
	if searchOptions != nil && searchOptions.SessionID != nil {
		reqQP.Set("sessionId", *searchOptions.SessionID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	return req, nil
}

// searchGetHandleResponse handles the SearchGet response.
func (client *DocumentsClient) searchGetHandleResponse(resp *http.Response) (DocumentsClientSearchGetResponse, error) {
	result := DocumentsClientSearchGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SearchDocumentsResult); err != nil {
		return DocumentsClientSearchGetResponse{}, err
	}
	return result, nil
}

// SearchPost - Searches for documents in the index.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - searchRequest - The definition of the Search request.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientSearchPostOptions contains the optional parameters for the DocumentsClient.SearchPost method.
func (client *DocumentsClient) SearchPost(ctx context.Context, searchRequest SearchRequest, requestOptions *RequestOptions, options *DocumentsClientSearchPostOptions) (DocumentsClientSearchPostResponse, error) {
	var err error
	req, err := client.searchPostCreateRequest(ctx, searchRequest, requestOptions, options)
	if err != nil {
		return DocumentsClientSearchPostResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientSearchPostResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientSearchPostResponse{}, err
	}
	resp, err := client.searchPostHandleResponse(httpResp)
	return resp, err
}

// searchPostCreateRequest creates the SearchPost request.
func (client *DocumentsClient) searchPostCreateRequest(ctx context.Context, searchRequest SearchRequest, requestOptions *RequestOptions, _ *DocumentsClientSearchPostOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.post.search"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	if err := runtime.MarshalAsJSON(req, searchRequest); err != nil {
	return nil, err
}
	return req, nil
}

// searchPostHandleResponse handles the SearchPost response.
func (client *DocumentsClient) searchPostHandleResponse(resp *http.Response) (DocumentsClientSearchPostResponse, error) {
	result := DocumentsClientSearchPostResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SearchDocumentsResult); err != nil {
		return DocumentsClientSearchPostResponse{}, err
	}
	return result, nil
}

// SuggestGet - Suggests documents in the index that match the given partial query text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.
//   - suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
//   - SuggestOptions - SuggestOptions contains a group of parameters for the DocumentsClient.SuggestGet method.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientSuggestGetOptions contains the optional parameters for the DocumentsClient.SuggestGet method.
func (client *DocumentsClient) SuggestGet(ctx context.Context, searchText string, suggesterName string, suggestOptions *SuggestOptions, requestOptions *RequestOptions, options *DocumentsClientSuggestGetOptions) (DocumentsClientSuggestGetResponse, error) {
	var err error
	req, err := client.suggestGetCreateRequest(ctx, searchText, suggesterName, suggestOptions, requestOptions, options)
	if err != nil {
		return DocumentsClientSuggestGetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientSuggestGetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientSuggestGetResponse{}, err
	}
	resp, err := client.suggestGetHandleResponse(httpResp)
	return resp, err
}

// suggestGetCreateRequest creates the SuggestGet request.
func (client *DocumentsClient) suggestGetCreateRequest(ctx context.Context, searchText string, suggesterName string, suggestOptions *SuggestOptions, requestOptions *RequestOptions, _ *DocumentsClientSuggestGetOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.suggest"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if suggestOptions != nil && suggestOptions.Filter != nil {
		reqQP.Set("$filter", *suggestOptions.Filter)
	}
	if suggestOptions != nil && suggestOptions.OrderBy != nil {
		reqQP.Set("$orderby", strings.Join(suggestOptions.OrderBy, ","))
	}
	if suggestOptions != nil && suggestOptions.Select != nil {
		reqQP.Set("$select", strings.Join(suggestOptions.Select, ","))
	}
	if suggestOptions != nil && suggestOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*suggestOptions.Top), 10))
	}
	reqQP.Set("api-version", "2024-07-01")
	if suggestOptions != nil && suggestOptions.UseFuzzyMatching != nil {
		reqQP.Set("fuzzy", strconv.FormatBool(*suggestOptions.UseFuzzyMatching))
	}
	if suggestOptions != nil && suggestOptions.HighlightPostTag != nil {
		reqQP.Set("highlightPostTag", *suggestOptions.HighlightPostTag)
	}
	if suggestOptions != nil && suggestOptions.HighlightPreTag != nil {
		reqQP.Set("highlightPreTag", *suggestOptions.HighlightPreTag)
	}
	if suggestOptions != nil && suggestOptions.MinimumCoverage != nil {
		reqQP.Set("minimumCoverage", strconv.FormatFloat(*suggestOptions.MinimumCoverage, 'f', -1, 64))
	}
	reqQP.Set("search", searchText)
	if suggestOptions != nil && suggestOptions.SearchFields != nil {
		reqQP.Set("searchFields", strings.Join(suggestOptions.SearchFields, ","))
	}
	reqQP.Set("suggesterName", suggesterName)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	return req, nil
}

// suggestGetHandleResponse handles the SuggestGet response.
func (client *DocumentsClient) suggestGetHandleResponse(resp *http.Response) (DocumentsClientSuggestGetResponse, error) {
	result := DocumentsClientSuggestGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SuggestDocumentsResult); err != nil {
		return DocumentsClientSuggestGetResponse{}, err
	}
	return result, nil
}

// SuggestPost - Suggests documents in the index that match the given partial query text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2024-07-01
//   - suggestRequest - The Suggest request.
//   - RequestOptions - RequestOptions contains a group of parameters for the DocumentsClient.Count method.
//   - options - DocumentsClientSuggestPostOptions contains the optional parameters for the DocumentsClient.SuggestPost method.
func (client *DocumentsClient) SuggestPost(ctx context.Context, suggestRequest SuggestRequest, requestOptions *RequestOptions, options *DocumentsClientSuggestPostOptions) (DocumentsClientSuggestPostResponse, error) {
	var err error
	req, err := client.suggestPostCreateRequest(ctx, suggestRequest, requestOptions, options)
	if err != nil {
		return DocumentsClientSuggestPostResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DocumentsClientSuggestPostResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return DocumentsClientSuggestPostResponse{}, err
	}
	resp, err := client.suggestPostHandleResponse(httpResp)
	return resp, err
}

// suggestPostCreateRequest creates the SuggestPost request.
func (client *DocumentsClient) suggestPostCreateRequest(ctx context.Context, suggestRequest SuggestRequest, requestOptions *RequestOptions, _ *DocumentsClientSuggestPostOptions) (*policy.Request, error) {
	host := "{endpoint}/indexes('{indexName}')"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	host = strings.ReplaceAll(host, "{indexName}", client.indexName)
	urlPath := "/docs/search.post.suggest"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-07-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if requestOptions != nil && requestOptions.XMSClientRequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*requestOptions.XMSClientRequestID}
	}
	if err := runtime.MarshalAsJSON(req, suggestRequest); err != nil {
	return nil, err
}
	return req, nil
}

// suggestPostHandleResponse handles the SuggestPost response.
func (client *DocumentsClient) suggestPostHandleResponse(resp *http.Response) (DocumentsClientSuggestPostResponse, error) {
	result := DocumentsClientSuggestPostResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SuggestDocumentsResult); err != nil {
		return DocumentsClientSuggestPostResponse{}, err
	}
	return result, nil
}

