// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azsearch

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ASCIIFoldingTokenFilter.
func (a ASCIIFoldingTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", a.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.AsciiFoldingTokenFilter"
	populate(objectMap, "preserveOriginal", a.PreserveOriginal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ASCIIFoldingTokenFilter.
func (a *ASCIIFoldingTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "preserveOriginal":
				err = unpopulate(val, "PreserveOriginal", &a.PreserveOriginal)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeRequest.
func (a AnalyzeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "analyzer", a.Analyzer)
	populate(objectMap, "charFilters", a.CharFilters)
	populate(objectMap, "text", a.Text)
	populate(objectMap, "tokenFilters", a.TokenFilters)
	populate(objectMap, "tokenizer", a.Tokenizer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeRequest.
func (a *AnalyzeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analyzer":
				err = unpopulate(val, "Analyzer", &a.Analyzer)
			delete(rawMsg, key)
		case "charFilters":
				err = unpopulate(val, "CharFilters", &a.CharFilters)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		case "tokenFilters":
				err = unpopulate(val, "TokenFilters", &a.TokenFilters)
			delete(rawMsg, key)
		case "tokenizer":
				err = unpopulate(val, "Tokenizer", &a.Tokenizer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeResult.
func (a AnalyzeResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tokens", a.Tokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeResult.
func (a *AnalyzeResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tokens":
				err = unpopulate(val, "Tokens", &a.Tokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzedTokenInfo.
func (a AnalyzedTokenInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endOffset", a.EndOffset)
	populate(objectMap, "position", a.Position)
	populate(objectMap, "startOffset", a.StartOffset)
	populate(objectMap, "token", a.Token)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzedTokenInfo.
func (a *AnalyzedTokenInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endOffset":
				err = unpopulate(val, "EndOffset", &a.EndOffset)
			delete(rawMsg, key)
		case "position":
				err = unpopulate(val, "Position", &a.Position)
			delete(rawMsg, key)
		case "startOffset":
				err = unpopulate(val, "StartOffset", &a.StartOffset)
			delete(rawMsg, key)
		case "token":
				err = unpopulate(val, "Token", &a.Token)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureActiveDirectoryApplicationCredentials.
func (a AzureActiveDirectoryApplicationCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", a.ApplicationID)
	populate(objectMap, "applicationSecret", a.ApplicationSecret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureActiveDirectoryApplicationCredentials.
func (a *AzureActiveDirectoryApplicationCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
				err = unpopulate(val, "ApplicationID", &a.ApplicationID)
			delete(rawMsg, key)
		case "applicationSecret":
				err = unpopulate(val, "ApplicationSecret", &a.ApplicationSecret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureOpenAIEmbeddingSkill.
func (a AzureOpenAIEmbeddingSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiKey", a.APIKey)
	populate(objectMap, "authIdentity", a.AuthIdentity)
	populate(objectMap, "context", a.Context)
	populate(objectMap, "deploymentId", a.DeploymentName)
	populate(objectMap, "description", a.Description)
	populate(objectMap, "dimensions", a.Dimensions)
	populate(objectMap, "inputs", a.Inputs)
	populate(objectMap, "modelName", a.ModelName)
	populate(objectMap, "name", a.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill"
	populate(objectMap, "outputs", a.Outputs)
	populate(objectMap, "resourceUri", a.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureOpenAIEmbeddingSkill.
func (a *AzureOpenAIEmbeddingSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
				err = unpopulate(val, "APIKey", &a.APIKey)
			delete(rawMsg, key)
		case "authIdentity":
			a.AuthIdentity, err = unmarshalIndexerDataIdentityClassification(val)
			delete(rawMsg, key)
		case "context":
				err = unpopulate(val, "Context", &a.Context)
			delete(rawMsg, key)
		case "deploymentId":
				err = unpopulate(val, "DeploymentName", &a.DeploymentName)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &a.Description)
			delete(rawMsg, key)
		case "dimensions":
				err = unpopulate(val, "Dimensions", &a.Dimensions)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &a.Inputs)
			delete(rawMsg, key)
		case "modelName":
				err = unpopulate(val, "ModelName", &a.ModelName)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &a.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &a.Outputs)
			delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &a.ResourceURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureOpenAIParameters.
func (a AzureOpenAIParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiKey", a.APIKey)
	populate(objectMap, "authIdentity", a.AuthIdentity)
	populate(objectMap, "deploymentId", a.DeploymentName)
	populate(objectMap, "modelName", a.ModelName)
	populate(objectMap, "resourceUri", a.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureOpenAIParameters.
func (a *AzureOpenAIParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
				err = unpopulate(val, "APIKey", &a.APIKey)
			delete(rawMsg, key)
		case "authIdentity":
			a.AuthIdentity, err = unmarshalIndexerDataIdentityClassification(val)
			delete(rawMsg, key)
		case "deploymentId":
				err = unpopulate(val, "DeploymentName", &a.DeploymentName)
			delete(rawMsg, key)
		case "modelName":
				err = unpopulate(val, "ModelName", &a.ModelName)
			delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &a.ResourceURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureOpenAIVectorizer.
func (a AzureOpenAIVectorizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureOpenAIParameters", a.AzureOpenAIParameters)
	objectMap["kind"] = VectorSearchVectorizerKindAzureOpenAI
	populate(objectMap, "name", a.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureOpenAIVectorizer.
func (a *AzureOpenAIVectorizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureOpenAIParameters":
				err = unpopulate(val, "AzureOpenAIParameters", &a.AzureOpenAIParameters)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BM25Similarity.
func (b BM25Similarity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "b", b.B)
	populate(objectMap, "k1", b.K1)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.BM25Similarity"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BM25Similarity.
func (b *BM25Similarity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "b":
				err = unpopulate(val, "B", &b.B)
			delete(rawMsg, key)
		case "k1":
				err = unpopulate(val, "K1", &b.K1)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &b.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BinaryQuantizationCompressionConfiguration.
func (b BinaryQuantizationCompressionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "defaultOversampling", b.DefaultOversampling)
	objectMap["kind"] = VectorSearchCompressionKindBinaryQuantization
	populate(objectMap, "name", b.Name)
	populate(objectMap, "rerankWithOriginalVectors", b.RerankWithOriginalVectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryQuantizationCompressionConfiguration.
func (b *BinaryQuantizationCompressionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultOversampling":
				err = unpopulate(val, "DefaultOversampling", &b.DefaultOversampling)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &b.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "rerankWithOriginalVectors":
				err = unpopulate(val, "RerankWithOriginalVectors", &b.RerankWithOriginalVectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CharFilter.
func (c CharFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = c.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CharFilter.
func (c *CharFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CjkBigramTokenFilter.
func (c CjkBigramTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ignoreScripts", c.IgnoreScripts)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.CjkBigramTokenFilter"
	populate(objectMap, "outputUnigrams", c.OutputUnigrams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CjkBigramTokenFilter.
func (c *CjkBigramTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ignoreScripts":
				err = unpopulate(val, "IgnoreScripts", &c.IgnoreScripts)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "outputUnigrams":
				err = unpopulate(val, "OutputUnigrams", &c.OutputUnigrams)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClassicSimilarity.
func (c ClassicSimilarity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.ClassicSimilarity"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClassicSimilarity.
func (c *ClassicSimilarity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClassicTokenizer.
func (c ClassicTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", c.MaxTokenLength)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.ClassicTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClassicTokenizer.
func (c *ClassicTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &c.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CognitiveServicesAccount.
func (c CognitiveServicesAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", c.Description)
	objectMap["@odata.type"] = c.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CognitiveServicesAccount.
func (c *CognitiveServicesAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CognitiveServicesAccountKey.
func (c CognitiveServicesAccountKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "key", c.Key)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.CognitiveServicesByKey"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CognitiveServicesAccountKey.
func (c *CognitiveServicesAccountKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &c.Key)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommonGramTokenFilter.
func (c CommonGramTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commonWords", c.CommonWords)
	populate(objectMap, "ignoreCase", c.IgnoreCase)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.CommonGramTokenFilter"
	populate(objectMap, "queryMode", c.UseQueryMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonGramTokenFilter.
func (c *CommonGramTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonWords":
				err = unpopulate(val, "CommonWords", &c.CommonWords)
			delete(rawMsg, key)
		case "ignoreCase":
				err = unpopulate(val, "IgnoreCase", &c.IgnoreCase)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "queryMode":
				err = unpopulate(val, "UseQueryMode", &c.UseQueryMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConditionalSkill.
func (c ConditionalSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", c.Context)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "inputs", c.Inputs)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Util.ConditionalSkill"
	populate(objectMap, "outputs", c.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConditionalSkill.
func (c *ConditionalSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &c.Context)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &c.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &c.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CorsOptions.
func (c CorsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowedOrigins", c.AllowedOrigins)
	populate(objectMap, "maxAgeInSeconds", c.MaxAgeInSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CorsOptions.
func (c *CorsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedOrigins":
				err = unpopulate(val, "AllowedOrigins", &c.AllowedOrigins)
			delete(rawMsg, key)
		case "maxAgeInSeconds":
				err = unpopulate(val, "MaxAgeInSeconds", &c.MaxAgeInSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomAnalyzer.
func (c CustomAnalyzer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "charFilters", c.CharFilters)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.CustomAnalyzer"
	populate(objectMap, "tokenFilters", c.TokenFilters)
	populate(objectMap, "tokenizer", c.Tokenizer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomAnalyzer.
func (c *CustomAnalyzer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "charFilters":
				err = unpopulate(val, "CharFilters", &c.CharFilters)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "tokenFilters":
				err = unpopulate(val, "TokenFilters", &c.TokenFilters)
			delete(rawMsg, key)
		case "tokenizer":
				err = unpopulate(val, "Tokenizer", &c.Tokenizer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomEntity.
func (c CustomEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accentSensitive", c.AccentSensitive)
	populate(objectMap, "aliases", c.Aliases)
	populate(objectMap, "caseSensitive", c.CaseSensitive)
	populate(objectMap, "defaultAccentSensitive", c.DefaultAccentSensitive)
	populate(objectMap, "defaultCaseSensitive", c.DefaultCaseSensitive)
	populate(objectMap, "defaultFuzzyEditDistance", c.DefaultFuzzyEditDistance)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "fuzzyEditDistance", c.FuzzyEditDistance)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "subtype", c.Subtype)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEntity.
func (c *CustomEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accentSensitive":
				err = unpopulate(val, "AccentSensitive", &c.AccentSensitive)
			delete(rawMsg, key)
		case "aliases":
				err = unpopulate(val, "Aliases", &c.Aliases)
			delete(rawMsg, key)
		case "caseSensitive":
				err = unpopulate(val, "CaseSensitive", &c.CaseSensitive)
			delete(rawMsg, key)
		case "defaultAccentSensitive":
				err = unpopulate(val, "DefaultAccentSensitive", &c.DefaultAccentSensitive)
			delete(rawMsg, key)
		case "defaultCaseSensitive":
				err = unpopulate(val, "DefaultCaseSensitive", &c.DefaultCaseSensitive)
			delete(rawMsg, key)
		case "defaultFuzzyEditDistance":
				err = unpopulate(val, "DefaultFuzzyEditDistance", &c.DefaultFuzzyEditDistance)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "fuzzyEditDistance":
				err = unpopulate(val, "FuzzyEditDistance", &c.FuzzyEditDistance)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "subtype":
				err = unpopulate(val, "Subtype", &c.Subtype)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomEntityAlias.
func (c CustomEntityAlias) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accentSensitive", c.AccentSensitive)
	populate(objectMap, "caseSensitive", c.CaseSensitive)
	populate(objectMap, "fuzzyEditDistance", c.FuzzyEditDistance)
	populate(objectMap, "text", c.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEntityAlias.
func (c *CustomEntityAlias) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accentSensitive":
				err = unpopulate(val, "AccentSensitive", &c.AccentSensitive)
			delete(rawMsg, key)
		case "caseSensitive":
				err = unpopulate(val, "CaseSensitive", &c.CaseSensitive)
			delete(rawMsg, key)
		case "fuzzyEditDistance":
				err = unpopulate(val, "FuzzyEditDistance", &c.FuzzyEditDistance)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &c.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CustomEntityLookupSkill.
func (c CustomEntityLookupSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", c.Context)
	populate(objectMap, "defaultLanguageCode", c.DefaultLanguageCode)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "entitiesDefinitionUri", c.EntitiesDefinitionURI)
	populate(objectMap, "globalDefaultAccentSensitive", c.GlobalDefaultAccentSensitive)
	populate(objectMap, "globalDefaultCaseSensitive", c.GlobalDefaultCaseSensitive)
	populate(objectMap, "globalDefaultFuzzyEditDistance", c.GlobalDefaultFuzzyEditDistance)
	populate(objectMap, "inlineEntitiesDefinition", c.InlineEntitiesDefinition)
	populate(objectMap, "inputs", c.Inputs)
	populate(objectMap, "name", c.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.CustomEntityLookupSkill"
	populate(objectMap, "outputs", c.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomEntityLookupSkill.
func (c *CustomEntityLookupSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &c.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &c.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "entitiesDefinitionUri":
				err = unpopulate(val, "EntitiesDefinitionURI", &c.EntitiesDefinitionURI)
			delete(rawMsg, key)
		case "globalDefaultAccentSensitive":
				err = unpopulate(val, "GlobalDefaultAccentSensitive", &c.GlobalDefaultAccentSensitive)
			delete(rawMsg, key)
		case "globalDefaultCaseSensitive":
				err = unpopulate(val, "GlobalDefaultCaseSensitive", &c.GlobalDefaultCaseSensitive)
			delete(rawMsg, key)
		case "globalDefaultFuzzyEditDistance":
				err = unpopulate(val, "GlobalDefaultFuzzyEditDistance", &c.GlobalDefaultFuzzyEditDistance)
			delete(rawMsg, key)
		case "inlineEntitiesDefinition":
				err = unpopulate(val, "InlineEntitiesDefinition", &c.InlineEntitiesDefinition)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &c.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &c.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &c.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataChangeDetectionPolicy.
func (d DataChangeDetectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = d.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataChangeDetectionPolicy.
func (d *DataChangeDetectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &d.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataDeletionDetectionPolicy.
func (d DataDeletionDetectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = d.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataDeletionDetectionPolicy.
func (d *DataDeletionDetectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &d.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataSourceCredentials.
func (d DataSourceCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionString", d.ConnectionString)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataSourceCredentials.
func (d *DataSourceCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
				err = unpopulate(val, "ConnectionString", &d.ConnectionString)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DefaultCognitiveServicesAccount.
func (d DefaultCognitiveServicesAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.DefaultCognitiveServices"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DefaultCognitiveServicesAccount.
func (d *DefaultCognitiveServicesAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &d.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DictionaryDecompounderTokenFilter.
func (d DictionaryDecompounderTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxSubwordSize", d.MaxSubwordSize)
	populate(objectMap, "minSubwordSize", d.MinSubwordSize)
	populate(objectMap, "minWordSize", d.MinWordSize)
	populate(objectMap, "name", d.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter"
	populate(objectMap, "onlyLongestMatch", d.OnlyLongestMatch)
	populate(objectMap, "wordList", d.WordList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DictionaryDecompounderTokenFilter.
func (d *DictionaryDecompounderTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxSubwordSize":
				err = unpopulate(val, "MaxSubwordSize", &d.MaxSubwordSize)
			delete(rawMsg, key)
		case "minSubwordSize":
				err = unpopulate(val, "MinSubwordSize", &d.MinSubwordSize)
			delete(rawMsg, key)
		case "minWordSize":
				err = unpopulate(val, "MinWordSize", &d.MinWordSize)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &d.ODataType)
			delete(rawMsg, key)
		case "onlyLongestMatch":
				err = unpopulate(val, "OnlyLongestMatch", &d.OnlyLongestMatch)
			delete(rawMsg, key)
		case "wordList":
				err = unpopulate(val, "WordList", &d.WordList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistanceScoringFunction.
func (d DistanceScoringFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boost", d.Boost)
	populate(objectMap, "fieldName", d.FieldName)
	populate(objectMap, "interpolation", d.Interpolation)
	populate(objectMap, "distance", d.Parameters)
	objectMap["type"] = "distance"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistanceScoringFunction.
func (d *DistanceScoringFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boost":
				err = unpopulate(val, "Boost", &d.Boost)
			delete(rawMsg, key)
		case "fieldName":
				err = unpopulate(val, "FieldName", &d.FieldName)
			delete(rawMsg, key)
		case "interpolation":
				err = unpopulate(val, "Interpolation", &d.Interpolation)
			delete(rawMsg, key)
		case "distance":
				err = unpopulate(val, "Parameters", &d.Parameters)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistanceScoringParameters.
func (d DistanceScoringParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boostingDistance", d.BoostingDistance)
	populate(objectMap, "referencePointParameter", d.ReferencePointParameter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistanceScoringParameters.
func (d *DistanceScoringParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boostingDistance":
				err = unpopulate(val, "BoostingDistance", &d.BoostingDistance)
			delete(rawMsg, key)
		case "referencePointParameter":
				err = unpopulate(val, "ReferencePointParameter", &d.ReferencePointParameter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DocumentExtractionSkill.
func (d DocumentExtractionSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configuration", d.Configuration)
	populate(objectMap, "context", d.Context)
	populate(objectMap, "dataToExtract", d.DataToExtract)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "inputs", d.Inputs)
	populate(objectMap, "name", d.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Util.DocumentExtractionSkill"
	populate(objectMap, "outputs", d.Outputs)
	populate(objectMap, "parsingMode", d.ParsingMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentExtractionSkill.
func (d *DocumentExtractionSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
				err = unpopulate(val, "Configuration", &d.Configuration)
			delete(rawMsg, key)
		case "context":
				err = unpopulate(val, "Context", &d.Context)
			delete(rawMsg, key)
		case "dataToExtract":
				err = unpopulate(val, "DataToExtract", &d.DataToExtract)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &d.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &d.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &d.Outputs)
			delete(rawMsg, key)
		case "parsingMode":
				err = unpopulate(val, "ParsingMode", &d.ParsingMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeNGramTokenFilter.
func (e EdgeNGramTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", e.MaxGram)
	populate(objectMap, "minGram", e.MinGram)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.EdgeNGramTokenFilter"
	populate(objectMap, "side", e.Side)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeNGramTokenFilter.
func (e *EdgeNGramTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &e.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &e.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "side":
				err = unpopulate(val, "Side", &e.Side)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeNGramTokenFilterV2.
func (e EdgeNGramTokenFilterV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", e.MaxGram)
	populate(objectMap, "minGram", e.MinGram)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2"
	populate(objectMap, "side", e.Side)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeNGramTokenFilterV2.
func (e *EdgeNGramTokenFilterV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &e.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &e.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "side":
				err = unpopulate(val, "Side", &e.Side)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EdgeNGramTokenizer.
func (e EdgeNGramTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", e.MaxGram)
	populate(objectMap, "minGram", e.MinGram)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.EdgeNGramTokenizer"
	populate(objectMap, "tokenChars", e.TokenChars)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EdgeNGramTokenizer.
func (e *EdgeNGramTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &e.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &e.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "tokenChars":
				err = unpopulate(val, "TokenChars", &e.TokenChars)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ElisionTokenFilter.
func (e ElisionTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "articles", e.Articles)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.ElisionTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ElisionTokenFilter.
func (e *ElisionTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "articles":
				err = unpopulate(val, "Articles", &e.Articles)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityLinkingSkill.
func (e EntityLinkingSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", e.Context)
	populate(objectMap, "defaultLanguageCode", e.DefaultLanguageCode)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "inputs", e.Inputs)
	populate(objectMap, "minimumPrecision", e.MinimumPrecision)
	populate(objectMap, "modelVersion", e.ModelVersion)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.V3.EntityLinkingSkill"
	populate(objectMap, "outputs", e.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityLinkingSkill.
func (e *EntityLinkingSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &e.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &e.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &e.Inputs)
			delete(rawMsg, key)
		case "minimumPrecision":
				err = unpopulate(val, "MinimumPrecision", &e.MinimumPrecision)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &e.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &e.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityRecognitionSkill.
func (e EntityRecognitionSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "categories", e.Categories)
	populate(objectMap, "context", e.Context)
	populate(objectMap, "defaultLanguageCode", e.DefaultLanguageCode)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "includeTypelessEntities", e.IncludeTypelessEntities)
	populate(objectMap, "inputs", e.Inputs)
	populate(objectMap, "minimumPrecision", e.MinimumPrecision)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.EntityRecognitionSkill"
	populate(objectMap, "outputs", e.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityRecognitionSkill.
func (e *EntityRecognitionSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "categories":
				err = unpopulate(val, "Categories", &e.Categories)
			delete(rawMsg, key)
		case "context":
				err = unpopulate(val, "Context", &e.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &e.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "includeTypelessEntities":
				err = unpopulate(val, "IncludeTypelessEntities", &e.IncludeTypelessEntities)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &e.Inputs)
			delete(rawMsg, key)
		case "minimumPrecision":
				err = unpopulate(val, "MinimumPrecision", &e.MinimumPrecision)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &e.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EntityRecognitionSkillV3.
func (e EntityRecognitionSkillV3) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "categories", e.Categories)
	populate(objectMap, "context", e.Context)
	populate(objectMap, "defaultLanguageCode", e.DefaultLanguageCode)
	populate(objectMap, "description", e.Description)
	populate(objectMap, "inputs", e.Inputs)
	populate(objectMap, "minimumPrecision", e.MinimumPrecision)
	populate(objectMap, "modelVersion", e.ModelVersion)
	populate(objectMap, "name", e.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.V3.EntityRecognitionSkill"
	populate(objectMap, "outputs", e.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EntityRecognitionSkillV3.
func (e *EntityRecognitionSkillV3) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "categories":
				err = unpopulate(val, "Categories", &e.Categories)
			delete(rawMsg, key)
		case "context":
				err = unpopulate(val, "Context", &e.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &e.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &e.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &e.Inputs)
			delete(rawMsg, key)
		case "minimumPrecision":
				err = unpopulate(val, "MinimumPrecision", &e.MinimumPrecision)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &e.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &e.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &e.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExhaustiveKnnAlgorithmConfiguration.
func (e ExhaustiveKnnAlgorithmConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = VectorSearchAlgorithmKindExhaustiveKnn
	populate(objectMap, "name", e.Name)
	populate(objectMap, "exhaustiveKnnParameters", e.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExhaustiveKnnAlgorithmConfiguration.
func (e *ExhaustiveKnnAlgorithmConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "exhaustiveKnnParameters":
				err = unpopulate(val, "Parameters", &e.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExhaustiveKnnParameters.
func (e ExhaustiveKnnParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "metric", e.Metric)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExhaustiveKnnParameters.
func (e *ExhaustiveKnnParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metric":
				err = unpopulate(val, "Metric", &e.Metric)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Field.
func (f Field) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "analyzer", f.Analyzer)
	populate(objectMap, "facetable", f.Facetable)
	populate(objectMap, "fields", f.Fields)
	populate(objectMap, "filterable", f.Filterable)
	populate(objectMap, "indexAnalyzer", f.IndexAnalyzer)
	populate(objectMap, "key", f.Key)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "retrievable", f.Retrievable)
	populate(objectMap, "searchAnalyzer", f.SearchAnalyzer)
	populate(objectMap, "searchable", f.Searchable)
	populate(objectMap, "sortable", f.Sortable)
	populate(objectMap, "stored", f.Stored)
	populate(objectMap, "synonymMaps", f.SynonymMaps)
	populate(objectMap, "type", f.Type)
	populate(objectMap, "vectorEncoding", f.VectorEncodingFormat)
	populate(objectMap, "dimensions", f.VectorSearchDimensions)
	populate(objectMap, "vectorSearchProfile", f.VectorSearchProfileName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Field.
func (f *Field) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analyzer":
				err = unpopulate(val, "Analyzer", &f.Analyzer)
			delete(rawMsg, key)
		case "facetable":
				err = unpopulate(val, "Facetable", &f.Facetable)
			delete(rawMsg, key)
		case "fields":
				err = unpopulate(val, "Fields", &f.Fields)
			delete(rawMsg, key)
		case "filterable":
				err = unpopulate(val, "Filterable", &f.Filterable)
			delete(rawMsg, key)
		case "indexAnalyzer":
				err = unpopulate(val, "IndexAnalyzer", &f.IndexAnalyzer)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &f.Key)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "retrievable":
				err = unpopulate(val, "Retrievable", &f.Retrievable)
			delete(rawMsg, key)
		case "searchAnalyzer":
				err = unpopulate(val, "SearchAnalyzer", &f.SearchAnalyzer)
			delete(rawMsg, key)
		case "searchable":
				err = unpopulate(val, "Searchable", &f.Searchable)
			delete(rawMsg, key)
		case "sortable":
				err = unpopulate(val, "Sortable", &f.Sortable)
			delete(rawMsg, key)
		case "stored":
				err = unpopulate(val, "Stored", &f.Stored)
			delete(rawMsg, key)
		case "synonymMaps":
				err = unpopulate(val, "SynonymMaps", &f.SynonymMaps)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		case "vectorEncoding":
				err = unpopulate(val, "VectorEncodingFormat", &f.VectorEncodingFormat)
			delete(rawMsg, key)
		case "dimensions":
				err = unpopulate(val, "VectorSearchDimensions", &f.VectorSearchDimensions)
			delete(rawMsg, key)
		case "vectorSearchProfile":
				err = unpopulate(val, "VectorSearchProfileName", &f.VectorSearchProfileName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FieldMapping.
func (f FieldMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mappingFunction", f.MappingFunction)
	populate(objectMap, "sourceFieldName", f.SourceFieldName)
	populate(objectMap, "targetFieldName", f.TargetFieldName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FieldMapping.
func (f *FieldMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mappingFunction":
				err = unpopulate(val, "MappingFunction", &f.MappingFunction)
			delete(rawMsg, key)
		case "sourceFieldName":
				err = unpopulate(val, "SourceFieldName", &f.SourceFieldName)
			delete(rawMsg, key)
		case "targetFieldName":
				err = unpopulate(val, "TargetFieldName", &f.TargetFieldName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FieldMappingFunction.
func (f FieldMappingFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", f.Name)
	populate(objectMap, "parameters", f.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FieldMappingFunction.
func (f *FieldMappingFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &f.Name)
			delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FreshnessScoringFunction.
func (f FreshnessScoringFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boost", f.Boost)
	populate(objectMap, "fieldName", f.FieldName)
	populate(objectMap, "interpolation", f.Interpolation)
	populate(objectMap, "freshness", f.Parameters)
	objectMap["type"] = "freshness"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FreshnessScoringFunction.
func (f *FreshnessScoringFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boost":
				err = unpopulate(val, "Boost", &f.Boost)
			delete(rawMsg, key)
		case "fieldName":
				err = unpopulate(val, "FieldName", &f.FieldName)
			delete(rawMsg, key)
		case "interpolation":
				err = unpopulate(val, "Interpolation", &f.Interpolation)
			delete(rawMsg, key)
		case "freshness":
				err = unpopulate(val, "Parameters", &f.Parameters)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &f.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FreshnessScoringParameters.
func (f FreshnessScoringParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boostingDuration", f.BoostingDuration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FreshnessScoringParameters.
func (f *FreshnessScoringParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boostingDuration":
				err = unpopulate(val, "BoostingDuration", &f.BoostingDuration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GetIndexStatisticsResult.
func (g GetIndexStatisticsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "documentCount", g.DocumentCount)
	populate(objectMap, "storageSize", g.StorageSize)
	populate(objectMap, "vectorIndexSize", g.VectorIndexSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetIndexStatisticsResult.
func (g *GetIndexStatisticsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "documentCount":
				err = unpopulate(val, "DocumentCount", &g.DocumentCount)
			delete(rawMsg, key)
		case "storageSize":
				err = unpopulate(val, "StorageSize", &g.StorageSize)
			delete(rawMsg, key)
		case "vectorIndexSize":
				err = unpopulate(val, "VectorIndexSize", &g.VectorIndexSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HighWaterMarkChangeDetectionPolicy.
func (h HighWaterMarkChangeDetectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "highWaterMarkColumnName", h.HighWaterMarkColumnName)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HighWaterMarkChangeDetectionPolicy.
func (h *HighWaterMarkChangeDetectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "highWaterMarkColumnName":
				err = unpopulate(val, "HighWaterMarkColumnName", &h.HighWaterMarkColumnName)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &h.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HnswAlgorithmConfiguration.
func (h HnswAlgorithmConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = VectorSearchAlgorithmKindHnsw
	populate(objectMap, "name", h.Name)
	populate(objectMap, "hnswParameters", h.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HnswAlgorithmConfiguration.
func (h *HnswAlgorithmConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &h.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "hnswParameters":
				err = unpopulate(val, "Parameters", &h.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HnswParameters.
func (h HnswParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "efConstruction", h.EfConstruction)
	populate(objectMap, "efSearch", h.EfSearch)
	populate(objectMap, "m", h.M)
	populate(objectMap, "metric", h.Metric)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HnswParameters.
func (h *HnswParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "efConstruction":
				err = unpopulate(val, "EfConstruction", &h.EfConstruction)
			delete(rawMsg, key)
		case "efSearch":
				err = unpopulate(val, "EfSearch", &h.EfSearch)
			delete(rawMsg, key)
		case "m":
				err = unpopulate(val, "M", &h.M)
			delete(rawMsg, key)
		case "metric":
				err = unpopulate(val, "Metric", &h.Metric)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageAnalysisSkill.
func (i ImageAnalysisSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", i.Context)
	populate(objectMap, "defaultLanguageCode", i.DefaultLanguageCode)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "details", i.Details)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "name", i.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Vision.ImageAnalysisSkill"
	populate(objectMap, "outputs", i.Outputs)
	populate(objectMap, "visualFeatures", i.VisualFeatures)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageAnalysisSkill.
func (i *ImageAnalysisSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &i.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &i.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &i.Details)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &i.Outputs)
			delete(rawMsg, key)
		case "visualFeatures":
				err = unpopulate(val, "VisualFeatures", &i.VisualFeatures)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Index.
func (i Index) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "analyzers", i.Analyzers)
	populate(objectMap, "charFilters", i.CharFilters)
	populate(objectMap, "corsOptions", i.CorsOptions)
	populate(objectMap, "defaultScoringProfile", i.DefaultScoringProfile)
	populate(objectMap, "@odata.etag", i.ETag)
	populate(objectMap, "encryptionKey", i.EncryptionKey)
	populate(objectMap, "fields", i.Fields)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "scoringProfiles", i.ScoringProfiles)
	populate(objectMap, "semantic", i.SemanticSearch)
	populate(objectMap, "similarity", i.Similarity)
	populate(objectMap, "suggesters", i.Suggesters)
	populate(objectMap, "tokenFilters", i.TokenFilters)
	populate(objectMap, "tokenizers", i.Tokenizers)
	populate(objectMap, "vectorSearch", i.VectorSearch)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Index.
func (i *Index) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "analyzers":
			i.Analyzers, err = unmarshalLexicalAnalyzerClassificationArray(val)
			delete(rawMsg, key)
		case "charFilters":
			i.CharFilters, err = unmarshalCharFilterClassificationArray(val)
			delete(rawMsg, key)
		case "corsOptions":
				err = unpopulate(val, "CorsOptions", &i.CorsOptions)
			delete(rawMsg, key)
		case "defaultScoringProfile":
				err = unpopulate(val, "DefaultScoringProfile", &i.DefaultScoringProfile)
			delete(rawMsg, key)
		case "@odata.etag":
				err = unpopulate(val, "ETag", &i.ETag)
			delete(rawMsg, key)
		case "encryptionKey":
				err = unpopulate(val, "EncryptionKey", &i.EncryptionKey)
			delete(rawMsg, key)
		case "fields":
				err = unpopulate(val, "Fields", &i.Fields)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "scoringProfiles":
				err = unpopulate(val, "ScoringProfiles", &i.ScoringProfiles)
			delete(rawMsg, key)
		case "semantic":
				err = unpopulate(val, "SemanticSearch", &i.SemanticSearch)
			delete(rawMsg, key)
		case "similarity":
			i.Similarity, err = unmarshalSimilarityClassification(val)
			delete(rawMsg, key)
		case "suggesters":
				err = unpopulate(val, "Suggesters", &i.Suggesters)
			delete(rawMsg, key)
		case "tokenFilters":
			i.TokenFilters, err = unmarshalTokenFilterClassificationArray(val)
			delete(rawMsg, key)
		case "tokenizers":
			i.Tokenizers, err = unmarshalLexicalTokenizerClassificationArray(val)
			delete(rawMsg, key)
		case "vectorSearch":
				err = unpopulate(val, "VectorSearch", &i.VectorSearch)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Indexer.
func (i Indexer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataSourceName", i.DataSourceName)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "@odata.etag", i.ETag)
	populate(objectMap, "encryptionKey", i.EncryptionKey)
	populate(objectMap, "fieldMappings", i.FieldMappings)
	populate(objectMap, "disabled", i.IsDisabled)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "outputFieldMappings", i.OutputFieldMappings)
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "schedule", i.Schedule)
	populate(objectMap, "skillsetName", i.SkillsetName)
	populate(objectMap, "targetIndexName", i.TargetIndexName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Indexer.
func (i *Indexer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSourceName":
				err = unpopulate(val, "DataSourceName", &i.DataSourceName)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "@odata.etag":
				err = unpopulate(val, "ETag", &i.ETag)
			delete(rawMsg, key)
		case "encryptionKey":
				err = unpopulate(val, "EncryptionKey", &i.EncryptionKey)
			delete(rawMsg, key)
		case "fieldMappings":
				err = unpopulate(val, "FieldMappings", &i.FieldMappings)
			delete(rawMsg, key)
		case "disabled":
				err = unpopulate(val, "IsDisabled", &i.IsDisabled)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "outputFieldMappings":
				err = unpopulate(val, "OutputFieldMappings", &i.OutputFieldMappings)
			delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &i.Schedule)
			delete(rawMsg, key)
		case "skillsetName":
				err = unpopulate(val, "SkillsetName", &i.SkillsetName)
			delete(rawMsg, key)
		case "targetIndexName":
				err = unpopulate(val, "TargetIndexName", &i.TargetIndexName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerDataContainer.
func (i IndexerDataContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "query", i.Query)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerDataContainer.
func (i *IndexerDataContainer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "query":
				err = unpopulate(val, "Query", &i.Query)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerDataIdentity.
func (i IndexerDataIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = i.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerDataIdentity.
func (i *IndexerDataIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerDataNoneIdentity.
func (i IndexerDataNoneIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.DataNoneIdentity"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerDataNoneIdentity.
func (i *IndexerDataNoneIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerDataSource.
func (i IndexerDataSource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "container", i.Container)
	populate(objectMap, "credentials", i.Credentials)
	populate(objectMap, "dataChangeDetectionPolicy", i.DataChangeDetectionPolicy)
	populate(objectMap, "dataDeletionDetectionPolicy", i.DataDeletionDetectionPolicy)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "@odata.etag", i.ETag)
	populate(objectMap, "encryptionKey", i.EncryptionKey)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerDataSource.
func (i *IndexerDataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
				err = unpopulate(val, "Container", &i.Container)
			delete(rawMsg, key)
		case "credentials":
				err = unpopulate(val, "Credentials", &i.Credentials)
			delete(rawMsg, key)
		case "dataChangeDetectionPolicy":
			i.DataChangeDetectionPolicy, err = unmarshalDataChangeDetectionPolicyClassification(val)
			delete(rawMsg, key)
		case "dataDeletionDetectionPolicy":
			i.DataDeletionDetectionPolicy, err = unmarshalDataDeletionDetectionPolicyClassification(val)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "@odata.etag":
				err = unpopulate(val, "ETag", &i.ETag)
			delete(rawMsg, key)
		case "encryptionKey":
				err = unpopulate(val, "EncryptionKey", &i.EncryptionKey)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerDataUserAssignedIdentity.
func (i IndexerDataUserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.DataUserAssignedIdentity"
	populate(objectMap, "userAssignedIdentity", i.UserAssignedIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerDataUserAssignedIdentity.
func (i *IndexerDataUserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		case "userAssignedIdentity":
				err = unpopulate(val, "UserAssignedIdentity", &i.UserAssignedIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerError.
func (i IndexerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", i.Details)
	populate(objectMap, "documentationLink", i.DocumentationLink)
	populate(objectMap, "errorMessage", i.ErrorMessage)
	populate(objectMap, "key", i.Key)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "statusCode", i.StatusCode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerError.
func (i *IndexerError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
				err = unpopulate(val, "Details", &i.Details)
			delete(rawMsg, key)
		case "documentationLink":
				err = unpopulate(val, "DocumentationLink", &i.DocumentationLink)
			delete(rawMsg, key)
		case "errorMessage":
				err = unpopulate(val, "ErrorMessage", &i.ErrorMessage)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &i.Key)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "statusCode":
				err = unpopulate(val, "StatusCode", &i.StatusCode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerExecutionResult.
func (i IndexerExecutionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", i.EndTime)
	populate(objectMap, "errorMessage", i.ErrorMessage)
	populate(objectMap, "errors", i.Errors)
	populate(objectMap, "itemsFailed", i.FailedItemCount)
	populate(objectMap, "finalTrackingState", i.FinalTrackingState)
	populate(objectMap, "initialTrackingState", i.InitialTrackingState)
	populate(objectMap, "itemsProcessed", i.ItemCount)
	populateDateTimeRFC3339(objectMap, "startTime", i.StartTime)
	populate(objectMap, "status", i.Status)
	populate(objectMap, "warnings", i.Warnings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerExecutionResult.
func (i *IndexerExecutionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &i.EndTime)
			delete(rawMsg, key)
		case "errorMessage":
				err = unpopulate(val, "ErrorMessage", &i.ErrorMessage)
			delete(rawMsg, key)
		case "errors":
				err = unpopulate(val, "Errors", &i.Errors)
			delete(rawMsg, key)
		case "itemsFailed":
				err = unpopulate(val, "FailedItemCount", &i.FailedItemCount)
			delete(rawMsg, key)
		case "finalTrackingState":
				err = unpopulate(val, "FinalTrackingState", &i.FinalTrackingState)
			delete(rawMsg, key)
		case "initialTrackingState":
				err = unpopulate(val, "InitialTrackingState", &i.InitialTrackingState)
			delete(rawMsg, key)
		case "itemsProcessed":
				err = unpopulate(val, "ItemCount", &i.ItemCount)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &i.StartTime)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &i.Status)
			delete(rawMsg, key)
		case "warnings":
				err = unpopulate(val, "Warnings", &i.Warnings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerIndexProjectionSelector.
func (i IndexerIndexProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mappings", i.Mappings)
	populate(objectMap, "parentKeyFieldName", i.ParentKeyFieldName)
	populate(objectMap, "sourceContext", i.SourceContext)
	populate(objectMap, "targetIndexName", i.TargetIndexName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerIndexProjectionSelector.
func (i *IndexerIndexProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mappings":
				err = unpopulate(val, "Mappings", &i.Mappings)
			delete(rawMsg, key)
		case "parentKeyFieldName":
				err = unpopulate(val, "ParentKeyFieldName", &i.ParentKeyFieldName)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		case "targetIndexName":
				err = unpopulate(val, "TargetIndexName", &i.TargetIndexName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerIndexProjections.
func (i IndexerIndexProjections) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", i.Parameters)
	populate(objectMap, "selectors", i.Selectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerIndexProjections.
func (i *IndexerIndexProjections) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &i.Parameters)
			delete(rawMsg, key)
		case "selectors":
				err = unpopulate(val, "Selectors", &i.Selectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerIndexProjectionsParameters.
func (i IndexerIndexProjectionsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "projectionMode", i.ProjectionMode)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerIndexProjectionsParameters.
func (i *IndexerIndexProjectionsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "projectionMode":
				err = unpopulate(val, "ProjectionMode", &i.ProjectionMode)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStore.
func (i IndexerKnowledgeStore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "projections", i.Projections)
	populate(objectMap, "storageConnectionString", i.StorageConnectionString)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStore.
func (i *IndexerKnowledgeStore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "projections":
				err = unpopulate(val, "Projections", &i.Projections)
			delete(rawMsg, key)
		case "storageConnectionString":
				err = unpopulate(val, "StorageConnectionString", &i.StorageConnectionString)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreBlobProjectionSelector.
func (i IndexerKnowledgeStoreBlobProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generatedKeyName", i.GeneratedKeyName)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "referenceKeyName", i.ReferenceKeyName)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	populate(objectMap, "storageContainer", i.StorageContainer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreBlobProjectionSelector.
func (i *IndexerKnowledgeStoreBlobProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generatedKeyName":
				err = unpopulate(val, "GeneratedKeyName", &i.GeneratedKeyName)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "referenceKeyName":
				err = unpopulate(val, "ReferenceKeyName", &i.ReferenceKeyName)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		case "storageContainer":
				err = unpopulate(val, "StorageContainer", &i.StorageContainer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreFileProjectionSelector.
func (i IndexerKnowledgeStoreFileProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generatedKeyName", i.GeneratedKeyName)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "referenceKeyName", i.ReferenceKeyName)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	populate(objectMap, "storageContainer", i.StorageContainer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreFileProjectionSelector.
func (i *IndexerKnowledgeStoreFileProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generatedKeyName":
				err = unpopulate(val, "GeneratedKeyName", &i.GeneratedKeyName)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "referenceKeyName":
				err = unpopulate(val, "ReferenceKeyName", &i.ReferenceKeyName)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		case "storageContainer":
				err = unpopulate(val, "StorageContainer", &i.StorageContainer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreObjectProjectionSelector.
func (i IndexerKnowledgeStoreObjectProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generatedKeyName", i.GeneratedKeyName)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "referenceKeyName", i.ReferenceKeyName)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	populate(objectMap, "storageContainer", i.StorageContainer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreObjectProjectionSelector.
func (i *IndexerKnowledgeStoreObjectProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generatedKeyName":
				err = unpopulate(val, "GeneratedKeyName", &i.GeneratedKeyName)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "referenceKeyName":
				err = unpopulate(val, "ReferenceKeyName", &i.ReferenceKeyName)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		case "storageContainer":
				err = unpopulate(val, "StorageContainer", &i.StorageContainer)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreParameters.
func (i IndexerKnowledgeStoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "synthesizeGeneratedKeyName", i.SynthesizeGeneratedKeyName)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreParameters.
func (i *IndexerKnowledgeStoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "synthesizeGeneratedKeyName":
				err = unpopulate(val, "SynthesizeGeneratedKeyName", &i.SynthesizeGeneratedKeyName)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreProjection.
func (i IndexerKnowledgeStoreProjection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "files", i.Files)
	populate(objectMap, "objects", i.Objects)
	populate(objectMap, "tables", i.Tables)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreProjection.
func (i *IndexerKnowledgeStoreProjection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "files":
				err = unpopulate(val, "Files", &i.Files)
			delete(rawMsg, key)
		case "objects":
				err = unpopulate(val, "Objects", &i.Objects)
			delete(rawMsg, key)
		case "tables":
				err = unpopulate(val, "Tables", &i.Tables)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreProjectionSelector.
func (i IndexerKnowledgeStoreProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generatedKeyName", i.GeneratedKeyName)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "referenceKeyName", i.ReferenceKeyName)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreProjectionSelector.
func (i *IndexerKnowledgeStoreProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generatedKeyName":
				err = unpopulate(val, "GeneratedKeyName", &i.GeneratedKeyName)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "referenceKeyName":
				err = unpopulate(val, "ReferenceKeyName", &i.ReferenceKeyName)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerKnowledgeStoreTableProjectionSelector.
func (i IndexerKnowledgeStoreTableProjectionSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "generatedKeyName", i.GeneratedKeyName)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "referenceKeyName", i.ReferenceKeyName)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	populate(objectMap, "tableName", i.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerKnowledgeStoreTableProjectionSelector.
func (i *IndexerKnowledgeStoreTableProjectionSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "generatedKeyName":
				err = unpopulate(val, "GeneratedKeyName", &i.GeneratedKeyName)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "referenceKeyName":
				err = unpopulate(val, "ReferenceKeyName", &i.ReferenceKeyName)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		case "tableName":
				err = unpopulate(val, "TableName", &i.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerLimits.
func (i IndexerLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxDocumentContentCharactersToExtract", i.MaxDocumentContentCharactersToExtract)
	populate(objectMap, "maxDocumentExtractionSize", i.MaxDocumentExtractionSize)
	populate(objectMap, "maxRunTime", i.MaxRunTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerLimits.
func (i *IndexerLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxDocumentContentCharactersToExtract":
				err = unpopulate(val, "MaxDocumentContentCharactersToExtract", &i.MaxDocumentContentCharactersToExtract)
			delete(rawMsg, key)
		case "maxDocumentExtractionSize":
				err = unpopulate(val, "MaxDocumentExtractionSize", &i.MaxDocumentExtractionSize)
			delete(rawMsg, key)
		case "maxRunTime":
				err = unpopulate(val, "MaxRunTime", &i.MaxRunTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerSkill.
func (i IndexerSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", i.Context)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "name", i.Name)
	objectMap["@odata.type"] = i.ODataType
	populate(objectMap, "outputs", i.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerSkill.
func (i *IndexerSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &i.Context)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &i.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &i.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerSkillset.
func (i IndexerSkillset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "cognitiveServices", i.CognitiveServicesAccount)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "@odata.etag", i.ETag)
	populate(objectMap, "encryptionKey", i.EncryptionKey)
	populate(objectMap, "indexProjections", i.IndexProjections)
	populate(objectMap, "knowledgeStore", i.KnowledgeStore)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "skills", i.Skills)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerSkillset.
func (i *IndexerSkillset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cognitiveServices":
			i.CognitiveServicesAccount, err = unmarshalCognitiveServicesAccountClassification(val)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "@odata.etag":
				err = unpopulate(val, "ETag", &i.ETag)
			delete(rawMsg, key)
		case "encryptionKey":
				err = unpopulate(val, "EncryptionKey", &i.EncryptionKey)
			delete(rawMsg, key)
		case "indexProjections":
				err = unpopulate(val, "IndexProjections", &i.IndexProjections)
			delete(rawMsg, key)
		case "knowledgeStore":
				err = unpopulate(val, "KnowledgeStore", &i.KnowledgeStore)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "skills":
			i.Skills, err = unmarshalIndexerSkillClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerStatus2.
func (i IndexerStatus2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "executionHistory", i.ExecutionHistory)
	populate(objectMap, "lastResult", i.LastResult)
	populate(objectMap, "limits", i.Limits)
	populate(objectMap, "status", i.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerStatus2.
func (i *IndexerStatus2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionHistory":
				err = unpopulate(val, "ExecutionHistory", &i.ExecutionHistory)
			delete(rawMsg, key)
		case "lastResult":
				err = unpopulate(val, "LastResult", &i.LastResult)
			delete(rawMsg, key)
		case "limits":
				err = unpopulate(val, "Limits", &i.Limits)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &i.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexerWarning.
func (i IndexerWarning) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "details", i.Details)
	populate(objectMap, "documentationLink", i.DocumentationLink)
	populate(objectMap, "key", i.Key)
	populate(objectMap, "message", i.Message)
	populate(objectMap, "name", i.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexerWarning.
func (i *IndexerWarning) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "details":
				err = unpopulate(val, "Details", &i.Details)
			delete(rawMsg, key)
		case "documentationLink":
				err = unpopulate(val, "DocumentationLink", &i.DocumentationLink)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &i.Key)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexingParameters.
func (i IndexingParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "batchSize", i.BatchSize)
	populate(objectMap, "configuration", i.Configuration)
	populate(objectMap, "maxFailedItems", i.MaxFailedItems)
	populate(objectMap, "maxFailedItemsPerBatch", i.MaxFailedItemsPerBatch)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexingParameters.
func (i *IndexingParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSize":
				err = unpopulate(val, "BatchSize", &i.BatchSize)
			delete(rawMsg, key)
		case "configuration":
				err = unpopulate(val, "Configuration", &i.Configuration)
			delete(rawMsg, key)
		case "maxFailedItems":
				err = unpopulate(val, "MaxFailedItems", &i.MaxFailedItems)
			delete(rawMsg, key)
		case "maxFailedItemsPerBatch":
				err = unpopulate(val, "MaxFailedItemsPerBatch", &i.MaxFailedItemsPerBatch)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexingParametersConfiguration.
func (i IndexingParametersConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowSkillsetToReadFileData", i.AllowSkillsetToReadFileData)
	populate(objectMap, "dataToExtract", i.DataToExtract)
	populate(objectMap, "delimitedTextDelimiter", i.DelimitedTextDelimiter)
	populate(objectMap, "delimitedTextHeaders", i.DelimitedTextHeaders)
	populate(objectMap, "documentRoot", i.DocumentRoot)
	populate(objectMap, "excludedFileNameExtensions", i.ExcludedFileNameExtensions)
	populate(objectMap, "executionEnvironment", i.ExecutionEnvironment)
	populate(objectMap, "failOnUnprocessableDocument", i.FailOnUnprocessableDocument)
	populate(objectMap, "failOnUnsupportedContentType", i.FailOnUnsupportedContentType)
	populate(objectMap, "firstLineContainsHeaders", i.FirstLineContainsHeaders)
	populate(objectMap, "imageAction", i.ImageAction)
	populate(objectMap, "indexStorageMetadataOnlyForOversizedDocuments", i.IndexStorageMetadataOnlyForOversizedDocuments)
	populate(objectMap, "indexedFileNameExtensions", i.IndexedFileNameExtensions)
	populate(objectMap, "pdfTextRotationAlgorithm", i.PDFTextRotationAlgorithm)
	populate(objectMap, "parsingMode", i.ParsingMode)
	populate(objectMap, "queryTimeout", i.QueryTimeout)
	if i.AdditionalProperties != nil {
		for key, val := range i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexingParametersConfiguration.
func (i *IndexingParametersConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowSkillsetToReadFileData":
				err = unpopulate(val, "AllowSkillsetToReadFileData", &i.AllowSkillsetToReadFileData)
			delete(rawMsg, key)
		case "dataToExtract":
				err = unpopulate(val, "DataToExtract", &i.DataToExtract)
			delete(rawMsg, key)
		case "delimitedTextDelimiter":
				err = unpopulate(val, "DelimitedTextDelimiter", &i.DelimitedTextDelimiter)
			delete(rawMsg, key)
		case "delimitedTextHeaders":
				err = unpopulate(val, "DelimitedTextHeaders", &i.DelimitedTextHeaders)
			delete(rawMsg, key)
		case "documentRoot":
				err = unpopulate(val, "DocumentRoot", &i.DocumentRoot)
			delete(rawMsg, key)
		case "excludedFileNameExtensions":
				err = unpopulate(val, "ExcludedFileNameExtensions", &i.ExcludedFileNameExtensions)
			delete(rawMsg, key)
		case "executionEnvironment":
				err = unpopulate(val, "ExecutionEnvironment", &i.ExecutionEnvironment)
			delete(rawMsg, key)
		case "failOnUnprocessableDocument":
				err = unpopulate(val, "FailOnUnprocessableDocument", &i.FailOnUnprocessableDocument)
			delete(rawMsg, key)
		case "failOnUnsupportedContentType":
				err = unpopulate(val, "FailOnUnsupportedContentType", &i.FailOnUnsupportedContentType)
			delete(rawMsg, key)
		case "firstLineContainsHeaders":
				err = unpopulate(val, "FirstLineContainsHeaders", &i.FirstLineContainsHeaders)
			delete(rawMsg, key)
		case "imageAction":
				err = unpopulate(val, "ImageAction", &i.ImageAction)
			delete(rawMsg, key)
		case "indexStorageMetadataOnlyForOversizedDocuments":
				err = unpopulate(val, "IndexStorageMetadataOnlyForOversizedDocuments", &i.IndexStorageMetadataOnlyForOversizedDocuments)
			delete(rawMsg, key)
		case "indexedFileNameExtensions":
				err = unpopulate(val, "IndexedFileNameExtensions", &i.IndexedFileNameExtensions)
			delete(rawMsg, key)
		case "pdfTextRotationAlgorithm":
				err = unpopulate(val, "PDFTextRotationAlgorithm", &i.PDFTextRotationAlgorithm)
			delete(rawMsg, key)
		case "parsingMode":
				err = unpopulate(val, "ParsingMode", &i.ParsingMode)
			delete(rawMsg, key)
		case "queryTimeout":
				err = unpopulate(val, "QueryTimeout", &i.QueryTimeout)
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				i.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexingSchedule.
func (i IndexingSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interval", i.Interval)
	populateDateTimeRFC3339(objectMap, "startTime", i.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexingSchedule.
func (i *IndexingSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interval":
				err = unpopulate(val, "Interval", &i.Interval)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &i.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InputFieldMappingEntry.
func (i InputFieldMappingEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "inputs", i.Inputs)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "source", i.Source)
	populate(objectMap, "sourceContext", i.SourceContext)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InputFieldMappingEntry.
func (i *InputFieldMappingEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
				err = unpopulate(val, "Inputs", &i.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &i.Source)
			delete(rawMsg, key)
		case "sourceContext":
				err = unpopulate(val, "SourceContext", &i.SourceContext)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeepTokenFilter.
func (k KeepTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keepWords", k.KeepWords)
	populate(objectMap, "keepWordsCase", k.LowerCaseKeepWords)
	populate(objectMap, "name", k.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.KeepTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeepTokenFilter.
func (k *KeepTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keepWords":
				err = unpopulate(val, "KeepWords", &k.KeepWords)
			delete(rawMsg, key)
		case "keepWordsCase":
				err = unpopulate(val, "LowerCaseKeepWords", &k.LowerCaseKeepWords)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &k.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyPhraseExtractionSkill.
func (k KeyPhraseExtractionSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", k.Context)
	populate(objectMap, "defaultLanguageCode", k.DefaultLanguageCode)
	populate(objectMap, "description", k.Description)
	populate(objectMap, "inputs", k.Inputs)
	populate(objectMap, "maxKeyPhraseCount", k.MaxKeyPhraseCount)
	populate(objectMap, "modelVersion", k.ModelVersion)
	populate(objectMap, "name", k.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.KeyPhraseExtractionSkill"
	populate(objectMap, "outputs", k.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyPhraseExtractionSkill.
func (k *KeyPhraseExtractionSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &k.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &k.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &k.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &k.Inputs)
			delete(rawMsg, key)
		case "maxKeyPhraseCount":
				err = unpopulate(val, "MaxKeyPhraseCount", &k.MaxKeyPhraseCount)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &k.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &k.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &k.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeywordMarkerTokenFilter.
func (k KeywordMarkerTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ignoreCase", k.IgnoreCase)
	populate(objectMap, "keywords", k.Keywords)
	populate(objectMap, "name", k.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.KeywordMarkerTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeywordMarkerTokenFilter.
func (k *KeywordMarkerTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ignoreCase":
				err = unpopulate(val, "IgnoreCase", &k.IgnoreCase)
			delete(rawMsg, key)
		case "keywords":
				err = unpopulate(val, "Keywords", &k.Keywords)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &k.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeywordTokenizer.
func (k KeywordTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bufferSize", k.BufferSize)
	populate(objectMap, "name", k.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.KeywordTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeywordTokenizer.
func (k *KeywordTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bufferSize":
				err = unpopulate(val, "BufferSize", &k.BufferSize)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &k.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeywordTokenizerV2.
func (k KeywordTokenizerV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", k.MaxTokenLength)
	populate(objectMap, "name", k.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.KeywordTokenizerV2"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeywordTokenizerV2.
func (k *KeywordTokenizerV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &k.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &k.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LanguageDetectionSkill.
func (l LanguageDetectionSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", l.Context)
	populate(objectMap, "defaultCountryHint", l.DefaultCountryHint)
	populate(objectMap, "description", l.Description)
	populate(objectMap, "inputs", l.Inputs)
	populate(objectMap, "modelVersion", l.ModelVersion)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.LanguageDetectionSkill"
	populate(objectMap, "outputs", l.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LanguageDetectionSkill.
func (l *LanguageDetectionSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &l.Context)
			delete(rawMsg, key)
		case "defaultCountryHint":
				err = unpopulate(val, "DefaultCountryHint", &l.DefaultCountryHint)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &l.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &l.Inputs)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &l.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &l.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LengthTokenFilter.
func (l LengthTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "max", l.MaxLength)
	populate(objectMap, "min", l.MinLength)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.LengthTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LengthTokenFilter.
func (l *LengthTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "max":
				err = unpopulate(val, "MaxLength", &l.MaxLength)
			delete(rawMsg, key)
		case "min":
				err = unpopulate(val, "MinLength", &l.MinLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LexicalAnalyzer.
func (l LexicalAnalyzer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = l.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LexicalAnalyzer.
func (l *LexicalAnalyzer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LexicalTokenizer.
func (l LexicalTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = l.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LexicalTokenizer.
func (l *LexicalTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LimitTokenFilter.
func (l LimitTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "consumeAllTokens", l.ConsumeAllTokens)
	populate(objectMap, "maxTokenCount", l.MaxTokenCount)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.LimitTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LimitTokenFilter.
func (l *LimitTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consumeAllTokens":
				err = unpopulate(val, "ConsumeAllTokens", &l.ConsumeAllTokens)
			delete(rawMsg, key)
		case "maxTokenCount":
				err = unpopulate(val, "MaxTokenCount", &l.MaxTokenCount)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListDataSourcesResult.
func (l ListDataSourcesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", l.DataSources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListDataSourcesResult.
func (l *ListDataSourcesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "DataSources", &l.DataSources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListIndexersResult.
func (l ListIndexersResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", l.Indexers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListIndexersResult.
func (l *ListIndexersResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Indexers", &l.Indexers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListIndexesResult.
func (l ListIndexesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", l.Indexes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListIndexesResult.
func (l *ListIndexesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Indexes", &l.Indexes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListSkillsetsResult.
func (l ListSkillsetsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", l.Skillsets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListSkillsetsResult.
func (l *ListSkillsetsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Skillsets", &l.Skillsets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListSynonymMapsResult.
func (l ListSynonymMapsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", l.SynonymMaps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListSynonymMapsResult.
func (l *ListSynonymMapsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "SynonymMaps", &l.SynonymMaps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LuceneStandardAnalyzer.
func (l LuceneStandardAnalyzer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", l.MaxTokenLength)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StandardAnalyzer"
	populate(objectMap, "stopwords", l.Stopwords)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LuceneStandardAnalyzer.
func (l *LuceneStandardAnalyzer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &l.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		case "stopwords":
				err = unpopulate(val, "Stopwords", &l.Stopwords)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LuceneStandardTokenizer.
func (l LuceneStandardTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", l.MaxTokenLength)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StandardTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LuceneStandardTokenizer.
func (l *LuceneStandardTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &l.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LuceneStandardTokenizerV2.
func (l LuceneStandardTokenizerV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", l.MaxTokenLength)
	populate(objectMap, "name", l.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StandardTokenizerV2"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LuceneStandardTokenizerV2.
func (l *LuceneStandardTokenizerV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &l.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &l.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &l.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagnitudeScoringFunction.
func (m MagnitudeScoringFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boost", m.Boost)
	populate(objectMap, "fieldName", m.FieldName)
	populate(objectMap, "interpolation", m.Interpolation)
	populate(objectMap, "magnitude", m.Parameters)
	objectMap["type"] = "magnitude"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagnitudeScoringFunction.
func (m *MagnitudeScoringFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boost":
				err = unpopulate(val, "Boost", &m.Boost)
			delete(rawMsg, key)
		case "fieldName":
				err = unpopulate(val, "FieldName", &m.FieldName)
			delete(rawMsg, key)
		case "interpolation":
				err = unpopulate(val, "Interpolation", &m.Interpolation)
			delete(rawMsg, key)
		case "magnitude":
				err = unpopulate(val, "Parameters", &m.Parameters)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MagnitudeScoringParameters.
func (m MagnitudeScoringParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boostingRangeEnd", m.BoostingRangeEnd)
	populate(objectMap, "boostingRangeStart", m.BoostingRangeStart)
	populate(objectMap, "constantBoostBeyondRange", m.ShouldBoostBeyondRangeByConstant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagnitudeScoringParameters.
func (m *MagnitudeScoringParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boostingRangeEnd":
				err = unpopulate(val, "BoostingRangeEnd", &m.BoostingRangeEnd)
			delete(rawMsg, key)
		case "boostingRangeStart":
				err = unpopulate(val, "BoostingRangeStart", &m.BoostingRangeStart)
			delete(rawMsg, key)
		case "constantBoostBeyondRange":
				err = unpopulate(val, "ShouldBoostBeyondRangeByConstant", &m.ShouldBoostBeyondRangeByConstant)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MappingCharFilter.
func (m MappingCharFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mappings", m.Mappings)
	populate(objectMap, "name", m.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.MappingCharFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingCharFilter.
func (m *MappingCharFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mappings":
				err = unpopulate(val, "Mappings", &m.Mappings)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MergeSkill.
func (m MergeSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", m.Context)
	populate(objectMap, "description", m.Description)
	populate(objectMap, "inputs", m.Inputs)
	populate(objectMap, "insertPostTag", m.InsertPostTag)
	populate(objectMap, "insertPreTag", m.InsertPreTag)
	populate(objectMap, "name", m.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.MergeSkill"
	populate(objectMap, "outputs", m.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MergeSkill.
func (m *MergeSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &m.Context)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &m.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &m.Inputs)
			delete(rawMsg, key)
		case "insertPostTag":
				err = unpopulate(val, "InsertPostTag", &m.InsertPostTag)
			delete(rawMsg, key)
		case "insertPreTag":
				err = unpopulate(val, "InsertPreTag", &m.InsertPreTag)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &m.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftLanguageStemmingTokenizer.
func (m MicrosoftLanguageStemmingTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSearchTokenizer", m.IsSearchTokenizer)
	populate(objectMap, "language", m.Language)
	populate(objectMap, "maxTokenLength", m.MaxTokenLength)
	populate(objectMap, "name", m.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftLanguageStemmingTokenizer.
func (m *MicrosoftLanguageStemmingTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSearchTokenizer":
				err = unpopulate(val, "IsSearchTokenizer", &m.IsSearchTokenizer)
			delete(rawMsg, key)
		case "language":
				err = unpopulate(val, "Language", &m.Language)
			delete(rawMsg, key)
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &m.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftLanguageTokenizer.
func (m MicrosoftLanguageTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isSearchTokenizer", m.IsSearchTokenizer)
	populate(objectMap, "language", m.Language)
	populate(objectMap, "maxTokenLength", m.MaxTokenLength)
	populate(objectMap, "name", m.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftLanguageTokenizer.
func (m *MicrosoftLanguageTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isSearchTokenizer":
				err = unpopulate(val, "IsSearchTokenizer", &m.IsSearchTokenizer)
			delete(rawMsg, key)
		case "language":
				err = unpopulate(val, "Language", &m.Language)
			delete(rawMsg, key)
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &m.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &m.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NGramTokenFilter.
func (n NGramTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", n.MaxGram)
	populate(objectMap, "minGram", n.MinGram)
	populate(objectMap, "name", n.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.NGramTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NGramTokenFilter.
func (n *NGramTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &n.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &n.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &n.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NGramTokenFilterV2.
func (n NGramTokenFilterV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", n.MaxGram)
	populate(objectMap, "minGram", n.MinGram)
	populate(objectMap, "name", n.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.NGramTokenFilterV2"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NGramTokenFilterV2.
func (n *NGramTokenFilterV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &n.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &n.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &n.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NGramTokenizer.
func (n NGramTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxGram", n.MaxGram)
	populate(objectMap, "minGram", n.MinGram)
	populate(objectMap, "name", n.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.NGramTokenizer"
	populate(objectMap, "tokenChars", n.TokenChars)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NGramTokenizer.
func (n *NGramTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxGram":
				err = unpopulate(val, "MaxGram", &n.MaxGram)
			delete(rawMsg, key)
		case "minGram":
				err = unpopulate(val, "MinGram", &n.MinGram)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &n.ODataType)
			delete(rawMsg, key)
		case "tokenChars":
				err = unpopulate(val, "TokenChars", &n.TokenChars)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OcrSkill.
func (o OcrSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", o.Context)
	populate(objectMap, "defaultLanguageCode", o.DefaultLanguageCode)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "inputs", o.Inputs)
	populate(objectMap, "lineEnding", o.LineEnding)
	populate(objectMap, "name", o.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Vision.OcrSkill"
	populate(objectMap, "outputs", o.Outputs)
	populate(objectMap, "detectOrientation", o.ShouldDetectOrientation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OcrSkill.
func (o *OcrSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &o.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &o.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &o.Inputs)
			delete(rawMsg, key)
		case "lineEnding":
				err = unpopulate(val, "LineEnding", &o.LineEnding)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &o.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &o.Outputs)
			delete(rawMsg, key)
		case "detectOrientation":
				err = unpopulate(val, "ShouldDetectOrientation", &o.ShouldDetectOrientation)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFieldMappingEntry.
func (o OutputFieldMappingEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "targetName", o.TargetName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFieldMappingEntry.
func (o *OutputFieldMappingEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "targetName":
				err = unpopulate(val, "TargetName", &o.TargetName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PIIDetectionSkill.
func (p PIIDetectionSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", p.Context)
	populate(objectMap, "defaultLanguageCode", p.DefaultLanguageCode)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "domain", p.Domain)
	populate(objectMap, "inputs", p.Inputs)
	populate(objectMap, "maskingCharacter", p.Mask)
	populate(objectMap, "maskingMode", p.MaskingMode)
	populate(objectMap, "minimumPrecision", p.MinimumPrecision)
	populate(objectMap, "modelVersion", p.ModelVersion)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.PIIDetectionSkill"
	populate(objectMap, "outputs", p.Outputs)
	populate(objectMap, "piiCategories", p.PiiCategories)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PIIDetectionSkill.
func (p *PIIDetectionSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &p.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &p.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "domain":
				err = unpopulate(val, "Domain", &p.Domain)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &p.Inputs)
			delete(rawMsg, key)
		case "maskingCharacter":
				err = unpopulate(val, "Mask", &p.Mask)
			delete(rawMsg, key)
		case "maskingMode":
				err = unpopulate(val, "MaskingMode", &p.MaskingMode)
			delete(rawMsg, key)
		case "minimumPrecision":
				err = unpopulate(val, "MinimumPrecision", &p.MinimumPrecision)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &p.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &p.Outputs)
			delete(rawMsg, key)
		case "piiCategories":
				err = unpopulate(val, "PiiCategories", &p.PiiCategories)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathHierarchyTokenizerV2.
func (p PathHierarchyTokenizerV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "delimiter", p.Delimiter)
	populate(objectMap, "maxTokenLength", p.MaxTokenLength)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "skip", p.NumberOfTokensToSkip)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PathHierarchyTokenizerV2"
	populate(objectMap, "replacement", p.Replacement)
	populate(objectMap, "reverse", p.ReverseTokenOrder)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PathHierarchyTokenizerV2.
func (p *PathHierarchyTokenizerV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delimiter":
				err = unpopulate(val, "Delimiter", &p.Delimiter)
			delete(rawMsg, key)
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &p.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "skip":
				err = unpopulate(val, "NumberOfTokensToSkip", &p.NumberOfTokensToSkip)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "replacement":
				err = unpopulate(val, "Replacement", &p.Replacement)
			delete(rawMsg, key)
		case "reverse":
				err = unpopulate(val, "ReverseTokenOrder", &p.ReverseTokenOrder)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatternAnalyzer.
func (p PatternAnalyzer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "flags", p.Flags)
	populate(objectMap, "lowercase", p.LowerCaseTerms)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PatternAnalyzer"
	populate(objectMap, "pattern", p.Pattern)
	populate(objectMap, "stopwords", p.Stopwords)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatternAnalyzer.
func (p *PatternAnalyzer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "flags":
				err = unpopulate(val, "Flags", &p.Flags)
			delete(rawMsg, key)
		case "lowercase":
				err = unpopulate(val, "LowerCaseTerms", &p.LowerCaseTerms)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "pattern":
				err = unpopulate(val, "Pattern", &p.Pattern)
			delete(rawMsg, key)
		case "stopwords":
				err = unpopulate(val, "Stopwords", &p.Stopwords)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatternCaptureTokenFilter.
func (p PatternCaptureTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PatternCaptureTokenFilter"
	populate(objectMap, "patterns", p.Patterns)
	populate(objectMap, "preserveOriginal", p.PreserveOriginal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatternCaptureTokenFilter.
func (p *PatternCaptureTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "patterns":
				err = unpopulate(val, "Patterns", &p.Patterns)
			delete(rawMsg, key)
		case "preserveOriginal":
				err = unpopulate(val, "PreserveOriginal", &p.PreserveOriginal)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatternReplaceCharFilter.
func (p PatternReplaceCharFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PatternReplaceCharFilter"
	populate(objectMap, "pattern", p.Pattern)
	populate(objectMap, "replacement", p.Replacement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatternReplaceCharFilter.
func (p *PatternReplaceCharFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "pattern":
				err = unpopulate(val, "Pattern", &p.Pattern)
			delete(rawMsg, key)
		case "replacement":
				err = unpopulate(val, "Replacement", &p.Replacement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatternReplaceTokenFilter.
func (p PatternReplaceTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PatternReplaceTokenFilter"
	populate(objectMap, "pattern", p.Pattern)
	populate(objectMap, "replacement", p.Replacement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatternReplaceTokenFilter.
func (p *PatternReplaceTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "pattern":
				err = unpopulate(val, "Pattern", &p.Pattern)
			delete(rawMsg, key)
		case "replacement":
				err = unpopulate(val, "Replacement", &p.Replacement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PatternTokenizer.
func (p PatternTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "flags", p.Flags)
	populate(objectMap, "group", p.Group)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PatternTokenizer"
	populate(objectMap, "pattern", p.Pattern)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PatternTokenizer.
func (p *PatternTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "flags":
				err = unpopulate(val, "Flags", &p.Flags)
			delete(rawMsg, key)
		case "group":
				err = unpopulate(val, "Group", &p.Group)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "pattern":
				err = unpopulate(val, "Pattern", &p.Pattern)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PhoneticTokenFilter.
func (p PhoneticTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encoder", p.Encoder)
	populate(objectMap, "name", p.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.PhoneticTokenFilter"
	populate(objectMap, "replace", p.ReplaceOriginalTokens)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoneticTokenFilter.
func (p *PhoneticTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encoder":
				err = unpopulate(val, "Encoder", &p.Encoder)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &p.ODataType)
			delete(rawMsg, key)
		case "replace":
				err = unpopulate(val, "ReplaceOriginalTokens", &p.ReplaceOriginalTokens)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceCounter.
func (r ResourceCounter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "quota", r.Quota)
	populate(objectMap, "usage", r.Usage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceCounter.
func (r *ResourceCounter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "quota":
				err = unpopulate(val, "Quota", &r.Quota)
			delete(rawMsg, key)
		case "usage":
				err = unpopulate(val, "Usage", &r.Usage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceEncryptionKey.
func (r ResourceEncryptionKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accessCredentials", r.AccessCredentials)
	populate(objectMap, "keyVaultKeyName", r.KeyName)
	populate(objectMap, "keyVaultKeyVersion", r.KeyVersion)
	populate(objectMap, "keyVaultUri", r.VaultURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceEncryptionKey.
func (r *ResourceEncryptionKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessCredentials":
				err = unpopulate(val, "AccessCredentials", &r.AccessCredentials)
			delete(rawMsg, key)
		case "keyVaultKeyName":
				err = unpopulate(val, "KeyName", &r.KeyName)
			delete(rawMsg, key)
		case "keyVaultKeyVersion":
				err = unpopulate(val, "KeyVersion", &r.KeyVersion)
			delete(rawMsg, key)
		case "keyVaultUri":
				err = unpopulate(val, "VaultURI", &r.VaultURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLIntegratedChangeTrackingPolicy.
func (s SQLIntegratedChangeTrackingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLIntegratedChangeTrackingPolicy.
func (s *SQLIntegratedChangeTrackingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScalarQuantizationCompressionConfiguration.
func (s ScalarQuantizationCompressionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "defaultOversampling", s.DefaultOversampling)
	objectMap["kind"] = VectorSearchCompressionKindScalarQuantization
	populate(objectMap, "name", s.Name)
	populate(objectMap, "scalarQuantizationParameters", s.Parameters)
	populate(objectMap, "rerankWithOriginalVectors", s.RerankWithOriginalVectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalarQuantizationCompressionConfiguration.
func (s *ScalarQuantizationCompressionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultOversampling":
				err = unpopulate(val, "DefaultOversampling", &s.DefaultOversampling)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "scalarQuantizationParameters":
				err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "rerankWithOriginalVectors":
				err = unpopulate(val, "RerankWithOriginalVectors", &s.RerankWithOriginalVectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScalarQuantizationParameters.
func (s ScalarQuantizationParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "quantizedDataType", s.QuantizedDataType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScalarQuantizationParameters.
func (s *ScalarQuantizationParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "quantizedDataType":
				err = unpopulate(val, "QuantizedDataType", &s.QuantizedDataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScoringFunction.
func (s ScoringFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boost", s.Boost)
	populate(objectMap, "fieldName", s.FieldName)
	populate(objectMap, "interpolation", s.Interpolation)
	objectMap["type"] = s.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScoringFunction.
func (s *ScoringFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boost":
				err = unpopulate(val, "Boost", &s.Boost)
			delete(rawMsg, key)
		case "fieldName":
				err = unpopulate(val, "FieldName", &s.FieldName)
			delete(rawMsg, key)
		case "interpolation":
				err = unpopulate(val, "Interpolation", &s.Interpolation)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScoringProfile.
func (s ScoringProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "functionAggregation", s.FunctionAggregation)
	populate(objectMap, "functions", s.Functions)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "text", s.TextWeights)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScoringProfile.
func (s *ScoringProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "functionAggregation":
				err = unpopulate(val, "FunctionAggregation", &s.FunctionAggregation)
			delete(rawMsg, key)
		case "functions":
			s.Functions, err = unmarshalScoringFunctionClassificationArray(val)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "TextWeights", &s.TextWeights)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SemanticConfiguration.
func (s SemanticConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "prioritizedFields", s.PrioritizedFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SemanticConfiguration.
func (s *SemanticConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "prioritizedFields":
				err = unpopulate(val, "PrioritizedFields", &s.PrioritizedFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SemanticField.
func (s SemanticField) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fieldName", s.FieldName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SemanticField.
func (s *SemanticField) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fieldName":
				err = unpopulate(val, "FieldName", &s.FieldName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SemanticPrioritizedFields.
func (s SemanticPrioritizedFields) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "prioritizedContentFields", s.ContentFields)
	populate(objectMap, "prioritizedKeywordsFields", s.KeywordsFields)
	populate(objectMap, "titleField", s.TitleField)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SemanticPrioritizedFields.
func (s *SemanticPrioritizedFields) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "prioritizedContentFields":
				err = unpopulate(val, "ContentFields", &s.ContentFields)
			delete(rawMsg, key)
		case "prioritizedKeywordsFields":
				err = unpopulate(val, "KeywordsFields", &s.KeywordsFields)
			delete(rawMsg, key)
		case "titleField":
				err = unpopulate(val, "TitleField", &s.TitleField)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SemanticSearch.
func (s SemanticSearch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configurations", s.Configurations)
	populate(objectMap, "defaultConfiguration", s.DefaultConfigurationName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SemanticSearch.
func (s *SemanticSearch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configurations":
				err = unpopulate(val, "Configurations", &s.Configurations)
			delete(rawMsg, key)
		case "defaultConfiguration":
				err = unpopulate(val, "DefaultConfigurationName", &s.DefaultConfigurationName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SentimentSkill.
func (s SentimentSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", s.Context)
	populate(objectMap, "defaultLanguageCode", s.DefaultLanguageCode)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.SentimentSkill"
	populate(objectMap, "outputs", s.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SentimentSkill.
func (s *SentimentSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &s.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &s.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &s.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &s.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SentimentSkillV3.
func (s SentimentSkillV3) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", s.Context)
	populate(objectMap, "defaultLanguageCode", s.DefaultLanguageCode)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "includeOpinionMining", s.IncludeOpinionMining)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "modelVersion", s.ModelVersion)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.V3.SentimentSkill"
	populate(objectMap, "outputs", s.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SentimentSkillV3.
func (s *SentimentSkillV3) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &s.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &s.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "includeOpinionMining":
				err = unpopulate(val, "IncludeOpinionMining", &s.IncludeOpinionMining)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &s.Inputs)
			delete(rawMsg, key)
		case "modelVersion":
				err = unpopulate(val, "ModelVersion", &s.ModelVersion)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &s.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceCounters.
func (s ServiceCounters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataSourcesCount", s.DataSourceCounter)
	populate(objectMap, "documentCount", s.DocumentCounter)
	populate(objectMap, "indexesCount", s.IndexCounter)
	populate(objectMap, "indexersCount", s.IndexerCounter)
	populate(objectMap, "skillsetCount", s.SkillsetCounter)
	populate(objectMap, "storageSize", s.StorageSizeCounter)
	populate(objectMap, "synonymMaps", s.SynonymMapCounter)
	populate(objectMap, "vectorIndexSize", s.VectorIndexSizeCounter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceCounters.
func (s *ServiceCounters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSourcesCount":
				err = unpopulate(val, "DataSourceCounter", &s.DataSourceCounter)
			delete(rawMsg, key)
		case "documentCount":
				err = unpopulate(val, "DocumentCounter", &s.DocumentCounter)
			delete(rawMsg, key)
		case "indexesCount":
				err = unpopulate(val, "IndexCounter", &s.IndexCounter)
			delete(rawMsg, key)
		case "indexersCount":
				err = unpopulate(val, "IndexerCounter", &s.IndexerCounter)
			delete(rawMsg, key)
		case "skillsetCount":
				err = unpopulate(val, "SkillsetCounter", &s.SkillsetCounter)
			delete(rawMsg, key)
		case "storageSize":
				err = unpopulate(val, "StorageSizeCounter", &s.StorageSizeCounter)
			delete(rawMsg, key)
		case "synonymMaps":
				err = unpopulate(val, "SynonymMapCounter", &s.SynonymMapCounter)
			delete(rawMsg, key)
		case "vectorIndexSize":
				err = unpopulate(val, "VectorIndexSizeCounter", &s.VectorIndexSizeCounter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceLimits.
func (s ServiceLimits) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxComplexCollectionFieldsPerIndex", s.MaxComplexCollectionFieldsPerIndex)
	populate(objectMap, "maxComplexObjectsInCollectionsPerDocument", s.MaxComplexObjectsInCollectionsPerDocument)
	populate(objectMap, "maxFieldNestingDepthPerIndex", s.MaxFieldNestingDepthPerIndex)
	populate(objectMap, "maxFieldsPerIndex", s.MaxFieldsPerIndex)
	populate(objectMap, "maxStoragePerIndex", s.MaxStoragePerIndexInBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceLimits.
func (s *ServiceLimits) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxComplexCollectionFieldsPerIndex":
				err = unpopulate(val, "MaxComplexCollectionFieldsPerIndex", &s.MaxComplexCollectionFieldsPerIndex)
			delete(rawMsg, key)
		case "maxComplexObjectsInCollectionsPerDocument":
				err = unpopulate(val, "MaxComplexObjectsInCollectionsPerDocument", &s.MaxComplexObjectsInCollectionsPerDocument)
			delete(rawMsg, key)
		case "maxFieldNestingDepthPerIndex":
				err = unpopulate(val, "MaxFieldNestingDepthPerIndex", &s.MaxFieldNestingDepthPerIndex)
			delete(rawMsg, key)
		case "maxFieldsPerIndex":
				err = unpopulate(val, "MaxFieldsPerIndex", &s.MaxFieldsPerIndex)
			delete(rawMsg, key)
		case "maxStoragePerIndex":
				err = unpopulate(val, "MaxStoragePerIndexInBytes", &s.MaxStoragePerIndexInBytes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceStatistics.
func (s ServiceStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "counters", s.Counters)
	populate(objectMap, "limits", s.Limits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceStatistics.
func (s *ServiceStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "counters":
				err = unpopulate(val, "Counters", &s.Counters)
			delete(rawMsg, key)
		case "limits":
				err = unpopulate(val, "Limits", &s.Limits)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShaperSkill.
func (s ShaperSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", s.Context)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Util.ShaperSkill"
	populate(objectMap, "outputs", s.Outputs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShaperSkill.
func (s *ShaperSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &s.Context)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &s.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &s.Outputs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ShingleTokenFilter.
func (s ShingleTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "filterToken", s.FilterToken)
	populate(objectMap, "maxShingleSize", s.MaxShingleSize)
	populate(objectMap, "minShingleSize", s.MinShingleSize)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.ShingleTokenFilter"
	populate(objectMap, "outputUnigrams", s.OutputUnigrams)
	populate(objectMap, "outputUnigramsIfNoShingles", s.OutputUnigramsIfNoShingles)
	populate(objectMap, "tokenSeparator", s.TokenSeparator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShingleTokenFilter.
func (s *ShingleTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filterToken":
				err = unpopulate(val, "FilterToken", &s.FilterToken)
			delete(rawMsg, key)
		case "maxShingleSize":
				err = unpopulate(val, "MaxShingleSize", &s.MaxShingleSize)
			delete(rawMsg, key)
		case "minShingleSize":
				err = unpopulate(val, "MinShingleSize", &s.MinShingleSize)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "outputUnigrams":
				err = unpopulate(val, "OutputUnigrams", &s.OutputUnigrams)
			delete(rawMsg, key)
		case "outputUnigramsIfNoShingles":
				err = unpopulate(val, "OutputUnigramsIfNoShingles", &s.OutputUnigramsIfNoShingles)
			delete(rawMsg, key)
		case "tokenSeparator":
				err = unpopulate(val, "TokenSeparator", &s.TokenSeparator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Similarity.
func (s Similarity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = s.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Similarity.
func (s *Similarity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnowballTokenFilter.
func (s SnowballTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "language", s.Language)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.SnowballTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnowballTokenFilter.
func (s *SnowballTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "language":
				err = unpopulate(val, "Language", &s.Language)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SoftDeleteColumnDeletionDetectionPolicy.
func (s SoftDeleteColumnDeletionDetectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
	populate(objectMap, "softDeleteColumnName", s.SoftDeleteColumnName)
	populate(objectMap, "softDeleteMarkerValue", s.SoftDeleteMarkerValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SoftDeleteColumnDeletionDetectionPolicy.
func (s *SoftDeleteColumnDeletionDetectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "softDeleteColumnName":
				err = unpopulate(val, "SoftDeleteColumnName", &s.SoftDeleteColumnName)
			delete(rawMsg, key)
		case "softDeleteMarkerValue":
				err = unpopulate(val, "SoftDeleteMarkerValue", &s.SoftDeleteMarkerValue)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SplitSkill.
func (s SplitSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", s.Context)
	populate(objectMap, "defaultLanguageCode", s.DefaultLanguageCode)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "inputs", s.Inputs)
	populate(objectMap, "maximumPageLength", s.MaximumPageLength)
	populate(objectMap, "maximumPagesToTake", s.MaximumPagesToTake)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.SplitSkill"
	populate(objectMap, "outputs", s.Outputs)
	populate(objectMap, "pageOverlapLength", s.PageOverlapLength)
	populate(objectMap, "textSplitMode", s.TextSplitMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SplitSkill.
func (s *SplitSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &s.Context)
			delete(rawMsg, key)
		case "defaultLanguageCode":
				err = unpopulate(val, "DefaultLanguageCode", &s.DefaultLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &s.Inputs)
			delete(rawMsg, key)
		case "maximumPageLength":
				err = unpopulate(val, "MaximumPageLength", &s.MaximumPageLength)
			delete(rawMsg, key)
		case "maximumPagesToTake":
				err = unpopulate(val, "MaximumPagesToTake", &s.MaximumPagesToTake)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &s.Outputs)
			delete(rawMsg, key)
		case "pageOverlapLength":
				err = unpopulate(val, "PageOverlapLength", &s.PageOverlapLength)
			delete(rawMsg, key)
		case "textSplitMode":
				err = unpopulate(val, "TextSplitMode", &s.TextSplitMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StemmerOverrideTokenFilter.
func (s StemmerOverrideTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StemmerOverrideTokenFilter"
	populate(objectMap, "rules", s.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StemmerOverrideTokenFilter.
func (s *StemmerOverrideTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "rules":
				err = unpopulate(val, "Rules", &s.Rules)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StemmerTokenFilter.
func (s StemmerTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "language", s.Language)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StemmerTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StemmerTokenFilter.
func (s *StemmerTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "language":
				err = unpopulate(val, "Language", &s.Language)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StopAnalyzer.
func (s StopAnalyzer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StopAnalyzer"
	populate(objectMap, "stopwords", s.Stopwords)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StopAnalyzer.
func (s *StopAnalyzer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "stopwords":
				err = unpopulate(val, "Stopwords", &s.Stopwords)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StopwordsTokenFilter.
func (s StopwordsTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ignoreCase", s.IgnoreCase)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.StopwordsTokenFilter"
	populate(objectMap, "removeTrailing", s.RemoveTrailingStopWords)
	populate(objectMap, "stopwords", s.Stopwords)
	populate(objectMap, "stopwordsList", s.StopwordsList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StopwordsTokenFilter.
func (s *StopwordsTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ignoreCase":
				err = unpopulate(val, "IgnoreCase", &s.IgnoreCase)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "removeTrailing":
				err = unpopulate(val, "RemoveTrailingStopWords", &s.RemoveTrailingStopWords)
			delete(rawMsg, key)
		case "stopwords":
				err = unpopulate(val, "Stopwords", &s.Stopwords)
			delete(rawMsg, key)
		case "stopwordsList":
				err = unpopulate(val, "StopwordsList", &s.StopwordsList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Suggester.
func (s Suggester) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	objectMap["searchMode"] = "analyzingInfixMatching"
	populate(objectMap, "sourceFields", s.SourceFields)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Suggester.
func (s *Suggester) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "searchMode":
				err = unpopulate(val, "SearchMode", &s.SearchMode)
			delete(rawMsg, key)
		case "sourceFields":
				err = unpopulate(val, "SourceFields", &s.SourceFields)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynonymMap.
func (s SynonymMap) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "@odata.etag", s.ETag)
	populate(objectMap, "encryptionKey", s.EncryptionKey)
	objectMap["format"] = "solr"
	populate(objectMap, "name", s.Name)
	populate(objectMap, "synonyms", s.Synonyms)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynonymMap.
func (s *SynonymMap) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "@odata.etag":
				err = unpopulate(val, "ETag", &s.ETag)
			delete(rawMsg, key)
		case "encryptionKey":
				err = unpopulate(val, "EncryptionKey", &s.EncryptionKey)
			delete(rawMsg, key)
		case "format":
				err = unpopulate(val, "Format", &s.Format)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "synonyms":
				err = unpopulate(val, "Synonyms", &s.Synonyms)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SynonymTokenFilter.
func (s SynonymTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expand", s.Expand)
	populate(objectMap, "ignoreCase", s.IgnoreCase)
	populate(objectMap, "name", s.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.SynonymTokenFilter"
	populate(objectMap, "synonyms", s.Synonyms)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynonymTokenFilter.
func (s *SynonymTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expand":
				err = unpopulate(val, "Expand", &s.Expand)
			delete(rawMsg, key)
		case "ignoreCase":
				err = unpopulate(val, "IgnoreCase", &s.IgnoreCase)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &s.ODataType)
			delete(rawMsg, key)
		case "synonyms":
				err = unpopulate(val, "Synonyms", &s.Synonyms)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagScoringFunction.
func (t TagScoringFunction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "boost", t.Boost)
	populate(objectMap, "fieldName", t.FieldName)
	populate(objectMap, "interpolation", t.Interpolation)
	populate(objectMap, "tag", t.Parameters)
	objectMap["type"] = "tag"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagScoringFunction.
func (t *TagScoringFunction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "boost":
				err = unpopulate(val, "Boost", &t.Boost)
			delete(rawMsg, key)
		case "fieldName":
				err = unpopulate(val, "FieldName", &t.FieldName)
			delete(rawMsg, key)
		case "interpolation":
				err = unpopulate(val, "Interpolation", &t.Interpolation)
			delete(rawMsg, key)
		case "tag":
				err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagScoringParameters.
func (t TagScoringParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tagsParameter", t.TagsParameter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagScoringParameters.
func (t *TagScoringParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tagsParameter":
				err = unpopulate(val, "TagsParameter", &t.TagsParameter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextTranslationSkill.
func (t TextTranslationSkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "context", t.Context)
	populate(objectMap, "defaultFromLanguageCode", t.DefaultFromLanguageCode)
	populate(objectMap, "defaultToLanguageCode", t.DefaultToLanguageCode)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "inputs", t.Inputs)
	populate(objectMap, "name", t.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Text.TranslationSkill"
	populate(objectMap, "outputs", t.Outputs)
	populate(objectMap, "suggestedFrom", t.SuggestedFrom)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextTranslationSkill.
func (t *TextTranslationSkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "context":
				err = unpopulate(val, "Context", &t.Context)
			delete(rawMsg, key)
		case "defaultFromLanguageCode":
				err = unpopulate(val, "DefaultFromLanguageCode", &t.DefaultFromLanguageCode)
			delete(rawMsg, key)
		case "defaultToLanguageCode":
				err = unpopulate(val, "DefaultToLanguageCode", &t.DefaultToLanguageCode)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &t.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &t.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &t.Outputs)
			delete(rawMsg, key)
		case "suggestedFrom":
				err = unpopulate(val, "SuggestedFrom", &t.SuggestedFrom)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextWeights.
func (t TextWeights) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "weights", t.Weights)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextWeights.
func (t *TextWeights) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "weights":
				err = unpopulate(val, "Weights", &t.Weights)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenFilter.
func (t TokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", t.Name)
	objectMap["@odata.type"] = t.ODataType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenFilter.
func (t *TokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &t.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TruncateTokenFilter.
func (t TruncateTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "length", t.Length)
	populate(objectMap, "name", t.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.TruncateTokenFilter"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TruncateTokenFilter.
func (t *TruncateTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "length":
				err = unpopulate(val, "Length", &t.Length)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &t.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UaxURLEmailTokenizer.
func (u UaxURLEmailTokenizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTokenLength", u.MaxTokenLength)
	populate(objectMap, "name", u.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.UaxUrlEmailTokenizer"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UaxURLEmailTokenizer.
func (u *UaxURLEmailTokenizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTokenLength":
				err = unpopulate(val, "MaxTokenLength", &u.MaxTokenLength)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &u.ODataType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UniqueTokenFilter.
func (u UniqueTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", u.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.UniqueTokenFilter"
	populate(objectMap, "onlyOnSamePosition", u.OnlyOnSamePosition)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UniqueTokenFilter.
func (u *UniqueTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &u.ODataType)
			delete(rawMsg, key)
		case "onlyOnSamePosition":
				err = unpopulate(val, "OnlyOnSamePosition", &u.OnlyOnSamePosition)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorSearch.
func (v VectorSearch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "algorithms", v.Algorithms)
	populate(objectMap, "compressions", v.Compressions)
	populate(objectMap, "profiles", v.Profiles)
	populate(objectMap, "vectorizers", v.Vectorizers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorSearch.
func (v *VectorSearch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "algorithms":
			v.Algorithms, err = unmarshalVectorSearchAlgorithmConfigurationClassificationArray(val)
			delete(rawMsg, key)
		case "compressions":
			v.Compressions, err = unmarshalVectorSearchCompressionConfigurationClassificationArray(val)
			delete(rawMsg, key)
		case "profiles":
				err = unpopulate(val, "Profiles", &v.Profiles)
			delete(rawMsg, key)
		case "vectorizers":
			v.Vectorizers, err = unmarshalVectorSearchVectorizerClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorSearchAlgorithmConfiguration.
func (v VectorSearchAlgorithmConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = v.Kind
	populate(objectMap, "name", v.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorSearchAlgorithmConfiguration.
func (v *VectorSearchAlgorithmConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorSearchCompressionConfiguration.
func (v VectorSearchCompressionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "defaultOversampling", v.DefaultOversampling)
	objectMap["kind"] = v.Kind
	populate(objectMap, "name", v.Name)
	populate(objectMap, "rerankWithOriginalVectors", v.RerankWithOriginalVectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorSearchCompressionConfiguration.
func (v *VectorSearchCompressionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultOversampling":
				err = unpopulate(val, "DefaultOversampling", &v.DefaultOversampling)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "rerankWithOriginalVectors":
				err = unpopulate(val, "RerankWithOriginalVectors", &v.RerankWithOriginalVectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorSearchProfile.
func (v VectorSearchProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "algorithm", v.AlgorithmConfigurationName)
	populate(objectMap, "compression", v.CompressionConfigurationName)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "vectorizer", v.VectorizerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorSearchProfile.
func (v *VectorSearchProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "algorithm":
				err = unpopulate(val, "AlgorithmConfigurationName", &v.AlgorithmConfigurationName)
			delete(rawMsg, key)
		case "compression":
				err = unpopulate(val, "CompressionConfigurationName", &v.CompressionConfigurationName)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "vectorizer":
				err = unpopulate(val, "VectorizerName", &v.VectorizerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VectorSearchVectorizer.
func (v VectorSearchVectorizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = v.Kind
	populate(objectMap, "name", v.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VectorSearchVectorizer.
func (v *VectorSearchVectorizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAPIParameters.
func (w WebAPIParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authIdentity", w.AuthIdentity)
	populate(objectMap, "authResourceId", w.AuthResourceID)
	populate(objectMap, "httpHeaders", w.HTTPHeaders)
	populate(objectMap, "httpMethod", w.HTTPMethod)
	populate(objectMap, "timeout", w.Timeout)
	populate(objectMap, "uri", w.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAPIParameters.
func (w *WebAPIParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authIdentity":
			w.AuthIdentity, err = unmarshalIndexerDataIdentityClassification(val)
			delete(rawMsg, key)
		case "authResourceId":
				err = unpopulate(val, "AuthResourceID", &w.AuthResourceID)
			delete(rawMsg, key)
		case "httpHeaders":
				err = unpopulate(val, "HTTPHeaders", &w.HTTPHeaders)
			delete(rawMsg, key)
		case "httpMethod":
				err = unpopulate(val, "HTTPMethod", &w.HTTPMethod)
			delete(rawMsg, key)
		case "timeout":
				err = unpopulate(val, "Timeout", &w.Timeout)
			delete(rawMsg, key)
		case "uri":
				err = unpopulate(val, "URI", &w.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAPISkill.
func (w WebAPISkill) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authIdentity", w.AuthIdentity)
	populate(objectMap, "authResourceId", w.AuthResourceID)
	populate(objectMap, "batchSize", w.BatchSize)
	populate(objectMap, "context", w.Context)
	populate(objectMap, "degreeOfParallelism", w.DegreeOfParallelism)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "httpHeaders", w.HTTPHeaders)
	populate(objectMap, "httpMethod", w.HTTPMethod)
	populate(objectMap, "inputs", w.Inputs)
	populate(objectMap, "name", w.Name)
	objectMap["@odata.type"] = "#Microsoft.Skills.Custom.WebApiSkill"
	populate(objectMap, "outputs", w.Outputs)
	populate(objectMap, "timeout", w.Timeout)
	populate(objectMap, "uri", w.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAPISkill.
func (w *WebAPISkill) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authIdentity":
			w.AuthIdentity, err = unmarshalIndexerDataIdentityClassification(val)
			delete(rawMsg, key)
		case "authResourceId":
				err = unpopulate(val, "AuthResourceID", &w.AuthResourceID)
			delete(rawMsg, key)
		case "batchSize":
				err = unpopulate(val, "BatchSize", &w.BatchSize)
			delete(rawMsg, key)
		case "context":
				err = unpopulate(val, "Context", &w.Context)
			delete(rawMsg, key)
		case "degreeOfParallelism":
				err = unpopulate(val, "DegreeOfParallelism", &w.DegreeOfParallelism)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "httpHeaders":
				err = unpopulate(val, "HTTPHeaders", &w.HTTPHeaders)
			delete(rawMsg, key)
		case "httpMethod":
				err = unpopulate(val, "HTTPMethod", &w.HTTPMethod)
			delete(rawMsg, key)
		case "inputs":
				err = unpopulate(val, "Inputs", &w.Inputs)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &w.ODataType)
			delete(rawMsg, key)
		case "outputs":
				err = unpopulate(val, "Outputs", &w.Outputs)
			delete(rawMsg, key)
		case "timeout":
				err = unpopulate(val, "Timeout", &w.Timeout)
			delete(rawMsg, key)
		case "uri":
				err = unpopulate(val, "URI", &w.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebAPIVectorizer.
func (w WebAPIVectorizer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = VectorSearchVectorizerKindCustomWebAPI
	populate(objectMap, "name", w.Name)
	populate(objectMap, "customWebApiParameters", w.WebAPIParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebAPIVectorizer.
func (w *WebAPIVectorizer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "customWebApiParameters":
				err = unpopulate(val, "WebAPIParameters", &w.WebAPIParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WordDelimiterTokenFilter.
func (w WordDelimiterTokenFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "catenateAll", w.CatenateAll)
	populate(objectMap, "catenateNumbers", w.CatenateNumbers)
	populate(objectMap, "catenateWords", w.CatenateWords)
	populate(objectMap, "generateNumberParts", w.GenerateNumberParts)
	populate(objectMap, "generateWordParts", w.GenerateWordParts)
	populate(objectMap, "name", w.Name)
	objectMap["@odata.type"] = "#Microsoft.Azure.Search.WordDelimiterTokenFilter"
	populate(objectMap, "preserveOriginal", w.PreserveOriginal)
	populate(objectMap, "protectedWords", w.ProtectedWords)
	populate(objectMap, "splitOnCaseChange", w.SplitOnCaseChange)
	populate(objectMap, "splitOnNumerics", w.SplitOnNumerics)
	populate(objectMap, "stemEnglishPossessive", w.StemEnglishPossessive)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WordDelimiterTokenFilter.
func (w *WordDelimiterTokenFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catenateAll":
				err = unpopulate(val, "CatenateAll", &w.CatenateAll)
			delete(rawMsg, key)
		case "catenateNumbers":
				err = unpopulate(val, "CatenateNumbers", &w.CatenateNumbers)
			delete(rawMsg, key)
		case "catenateWords":
				err = unpopulate(val, "CatenateWords", &w.CatenateWords)
			delete(rawMsg, key)
		case "generateNumberParts":
				err = unpopulate(val, "GenerateNumberParts", &w.GenerateNumberParts)
			delete(rawMsg, key)
		case "generateWordParts":
				err = unpopulate(val, "GenerateWordParts", &w.GenerateWordParts)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "@odata.type":
				err = unpopulate(val, "ODataType", &w.ODataType)
			delete(rawMsg, key)
		case "preserveOriginal":
				err = unpopulate(val, "PreserveOriginal", &w.PreserveOriginal)
			delete(rawMsg, key)
		case "protectedWords":
				err = unpopulate(val, "ProtectedWords", &w.ProtectedWords)
			delete(rawMsg, key)
		case "splitOnCaseChange":
				err = unpopulate(val, "SplitOnCaseChange", &w.SplitOnCaseChange)
			delete(rawMsg, key)
		case "splitOnNumerics":
				err = unpopulate(val, "SplitOnNumerics", &w.SplitOnNumerics)
			delete(rawMsg, key)
		case "stemEnglishPossessive":
				err = unpopulate(val, "StemEnglishPossessive", &w.StemEnglishPossessive)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

