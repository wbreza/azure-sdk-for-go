// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azsearch

import "encoding/json"

func unmarshalCharFilterClassification(rawMsg json.RawMessage) (CharFilterClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b CharFilterClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.MappingCharFilter":
		b = &MappingCharFilter{}
	case "#Microsoft.Azure.Search.PatternReplaceCharFilter":
		b = &PatternReplaceCharFilter{}
	default:
		b = &CharFilter{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalCharFilterClassificationArray(rawMsg json.RawMessage) ([]CharFilterClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CharFilterClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCharFilterClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalCognitiveServicesAccountClassification(rawMsg json.RawMessage) (CognitiveServicesAccountClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b CognitiveServicesAccountClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.CognitiveServicesByKey":
		b = &CognitiveServicesAccountKey{}
	case "#Microsoft.Azure.Search.DefaultCognitiveServices":
		b = &DefaultCognitiveServicesAccount{}
	default:
		b = &CognitiveServicesAccount{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalDataChangeDetectionPolicyClassification(rawMsg json.RawMessage) (DataChangeDetectionPolicyClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DataChangeDetectionPolicyClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
		b = &HighWaterMarkChangeDetectionPolicy{}
	case "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
		b = &SQLIntegratedChangeTrackingPolicy{}
	default:
		b = &DataChangeDetectionPolicy{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalDataDeletionDetectionPolicyClassification(rawMsg json.RawMessage) (DataDeletionDetectionPolicyClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DataDeletionDetectionPolicyClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
		b = &SoftDeleteColumnDeletionDetectionPolicy{}
	default:
		b = &DataDeletionDetectionPolicy{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalIndexerDataIdentityClassification(rawMsg json.RawMessage) (IndexerDataIdentityClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b IndexerDataIdentityClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.DataNoneIdentity":
		b = &IndexerDataNoneIdentity{}
	case "#Microsoft.Azure.Search.DataUserAssignedIdentity":
		b = &IndexerDataUserAssignedIdentity{}
	default:
		b = &IndexerDataIdentity{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalIndexerSkillClassification(rawMsg json.RawMessage) (IndexerSkillClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b IndexerSkillClassification
	switch m["@odata.type"] {
	case "#Microsoft.Skills.Custom.WebApiSkill":
		b = &WebAPISkill{}
	case "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill":
		b = &AzureOpenAIEmbeddingSkill{}
	case "#Microsoft.Skills.Text.CustomEntityLookupSkill":
		b = &CustomEntityLookupSkill{}
	case "#Microsoft.Skills.Text.EntityRecognitionSkill":
		b = &EntityRecognitionSkill{}
	case "#Microsoft.Skills.Text.KeyPhraseExtractionSkill":
		b = &KeyPhraseExtractionSkill{}
	case "#Microsoft.Skills.Text.LanguageDetectionSkill":
		b = &LanguageDetectionSkill{}
	case "#Microsoft.Skills.Text.MergeSkill":
		b = &MergeSkill{}
	case "#Microsoft.Skills.Text.PIIDetectionSkill":
		b = &PIIDetectionSkill{}
	case "#Microsoft.Skills.Text.SentimentSkill":
		b = &SentimentSkill{}
	case "#Microsoft.Skills.Text.SplitSkill":
		b = &SplitSkill{}
	case "#Microsoft.Skills.Text.TranslationSkill":
		b = &TextTranslationSkill{}
	case "#Microsoft.Skills.Text.V3.EntityLinkingSkill":
		b = &EntityLinkingSkill{}
	case "#Microsoft.Skills.Text.V3.EntityRecognitionSkill":
		b = &EntityRecognitionSkillV3{}
	case "#Microsoft.Skills.Text.V3.SentimentSkill":
		b = &SentimentSkillV3{}
	case "#Microsoft.Skills.Util.ConditionalSkill":
		b = &ConditionalSkill{}
	case "#Microsoft.Skills.Util.DocumentExtractionSkill":
		b = &DocumentExtractionSkill{}
	case "#Microsoft.Skills.Util.ShaperSkill":
		b = &ShaperSkill{}
	case "#Microsoft.Skills.Vision.ImageAnalysisSkill":
		b = &ImageAnalysisSkill{}
	case "#Microsoft.Skills.Vision.OcrSkill":
		b = &OcrSkill{}
	default:
		b = &IndexerSkill{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalIndexerSkillClassificationArray(rawMsg json.RawMessage) ([]IndexerSkillClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]IndexerSkillClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalIndexerSkillClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalLexicalAnalyzerClassification(rawMsg json.RawMessage) (LexicalAnalyzerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b LexicalAnalyzerClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.CustomAnalyzer":
		b = &CustomAnalyzer{}
	case "#Microsoft.Azure.Search.PatternAnalyzer":
		b = &PatternAnalyzer{}
	case "#Microsoft.Azure.Search.StandardAnalyzer":
		b = &LuceneStandardAnalyzer{}
	case "#Microsoft.Azure.Search.StopAnalyzer":
		b = &StopAnalyzer{}
	default:
		b = &LexicalAnalyzer{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalLexicalAnalyzerClassificationArray(rawMsg json.RawMessage) ([]LexicalAnalyzerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]LexicalAnalyzerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalLexicalAnalyzerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalLexicalTokenizerClassification(rawMsg json.RawMessage) (LexicalTokenizerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b LexicalTokenizerClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.ClassicTokenizer":
		b = &ClassicTokenizer{}
	case "#Microsoft.Azure.Search.EdgeNGramTokenizer":
		b = &EdgeNGramTokenizer{}
	case "#Microsoft.Azure.Search.KeywordTokenizer":
		b = &KeywordTokenizer{}
	case "#Microsoft.Azure.Search.KeywordTokenizerV2":
		b = &KeywordTokenizerV2{}
	case "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer":
		b = &MicrosoftLanguageStemmingTokenizer{}
	case "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer":
		b = &MicrosoftLanguageTokenizer{}
	case "#Microsoft.Azure.Search.NGramTokenizer":
		b = &NGramTokenizer{}
	case "#Microsoft.Azure.Search.PathHierarchyTokenizerV2":
		b = &PathHierarchyTokenizerV2{}
	case "#Microsoft.Azure.Search.PatternTokenizer":
		b = &PatternTokenizer{}
	case "#Microsoft.Azure.Search.StandardTokenizer":
		b = &LuceneStandardTokenizer{}
	case "#Microsoft.Azure.Search.StandardTokenizerV2":
		b = &LuceneStandardTokenizerV2{}
	case "#Microsoft.Azure.Search.UaxUrlEmailTokenizer":
		b = &UaxURLEmailTokenizer{}
	default:
		b = &LexicalTokenizer{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalLexicalTokenizerClassificationArray(rawMsg json.RawMessage) ([]LexicalTokenizerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]LexicalTokenizerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalLexicalTokenizerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalScoringFunctionClassification(rawMsg json.RawMessage) (ScoringFunctionClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ScoringFunctionClassification
	switch m["type"] {
	case "distance":
		b = &DistanceScoringFunction{}
	case "freshness":
		b = &FreshnessScoringFunction{}
	case "magnitude":
		b = &MagnitudeScoringFunction{}
	case "tag":
		b = &TagScoringFunction{}
	default:
		b = &ScoringFunction{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalScoringFunctionClassificationArray(rawMsg json.RawMessage) ([]ScoringFunctionClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ScoringFunctionClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalScoringFunctionClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSimilarityClassification(rawMsg json.RawMessage) (SimilarityClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SimilarityClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.BM25Similarity":
		b = &BM25Similarity{}
	case "#Microsoft.Azure.Search.ClassicSimilarity":
		b = &ClassicSimilarity{}
	default:
		b = &Similarity{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalTokenFilterClassification(rawMsg json.RawMessage) (TokenFilterClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b TokenFilterClassification
	switch m["@odata.type"] {
	case "#Microsoft.Azure.Search.AsciiFoldingTokenFilter":
		b = &ASCIIFoldingTokenFilter{}
	case "#Microsoft.Azure.Search.CjkBigramTokenFilter":
		b = &CjkBigramTokenFilter{}
	case "#Microsoft.Azure.Search.CommonGramTokenFilter":
		b = &CommonGramTokenFilter{}
	case "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter":
		b = &DictionaryDecompounderTokenFilter{}
	case "#Microsoft.Azure.Search.EdgeNGramTokenFilter":
		b = &EdgeNGramTokenFilter{}
	case "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2":
		b = &EdgeNGramTokenFilterV2{}
	case "#Microsoft.Azure.Search.ElisionTokenFilter":
		b = &ElisionTokenFilter{}
	case "#Microsoft.Azure.Search.KeepTokenFilter":
		b = &KeepTokenFilter{}
	case "#Microsoft.Azure.Search.KeywordMarkerTokenFilter":
		b = &KeywordMarkerTokenFilter{}
	case "#Microsoft.Azure.Search.LengthTokenFilter":
		b = &LengthTokenFilter{}
	case "#Microsoft.Azure.Search.LimitTokenFilter":
		b = &LimitTokenFilter{}
	case "#Microsoft.Azure.Search.NGramTokenFilter":
		b = &NGramTokenFilter{}
	case "#Microsoft.Azure.Search.NGramTokenFilterV2":
		b = &NGramTokenFilterV2{}
	case "#Microsoft.Azure.Search.PatternCaptureTokenFilter":
		b = &PatternCaptureTokenFilter{}
	case "#Microsoft.Azure.Search.PatternReplaceTokenFilter":
		b = &PatternReplaceTokenFilter{}
	case "#Microsoft.Azure.Search.PhoneticTokenFilter":
		b = &PhoneticTokenFilter{}
	case "#Microsoft.Azure.Search.ShingleTokenFilter":
		b = &ShingleTokenFilter{}
	case "#Microsoft.Azure.Search.SnowballTokenFilter":
		b = &SnowballTokenFilter{}
	case "#Microsoft.Azure.Search.StemmerOverrideTokenFilter":
		b = &StemmerOverrideTokenFilter{}
	case "#Microsoft.Azure.Search.StemmerTokenFilter":
		b = &StemmerTokenFilter{}
	case "#Microsoft.Azure.Search.StopwordsTokenFilter":
		b = &StopwordsTokenFilter{}
	case "#Microsoft.Azure.Search.SynonymTokenFilter":
		b = &SynonymTokenFilter{}
	case "#Microsoft.Azure.Search.TruncateTokenFilter":
		b = &TruncateTokenFilter{}
	case "#Microsoft.Azure.Search.UniqueTokenFilter":
		b = &UniqueTokenFilter{}
	case "#Microsoft.Azure.Search.WordDelimiterTokenFilter":
		b = &WordDelimiterTokenFilter{}
	default:
		b = &TokenFilter{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalTokenFilterClassificationArray(rawMsg json.RawMessage) ([]TokenFilterClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TokenFilterClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTokenFilterClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalVectorSearchAlgorithmConfigurationClassification(rawMsg json.RawMessage) (VectorSearchAlgorithmConfigurationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b VectorSearchAlgorithmConfigurationClassification
	switch m["kind"] {
	case string(VectorSearchAlgorithmKindExhaustiveKnn):
		b = &ExhaustiveKnnAlgorithmConfiguration{}
	case string(VectorSearchAlgorithmKindHnsw):
		b = &HnswAlgorithmConfiguration{}
	default:
		b = &VectorSearchAlgorithmConfiguration{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalVectorSearchAlgorithmConfigurationClassificationArray(rawMsg json.RawMessage) ([]VectorSearchAlgorithmConfigurationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]VectorSearchAlgorithmConfigurationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalVectorSearchAlgorithmConfigurationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalVectorSearchCompressionConfigurationClassification(rawMsg json.RawMessage) (VectorSearchCompressionConfigurationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b VectorSearchCompressionConfigurationClassification
	switch m["kind"] {
	case string(VectorSearchCompressionKindBinaryQuantization):
		b = &BinaryQuantizationCompressionConfiguration{}
	case string(VectorSearchCompressionKindScalarQuantization):
		b = &ScalarQuantizationCompressionConfiguration{}
	default:
		b = &VectorSearchCompressionConfiguration{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalVectorSearchCompressionConfigurationClassificationArray(rawMsg json.RawMessage) ([]VectorSearchCompressionConfigurationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]VectorSearchCompressionConfigurationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalVectorSearchCompressionConfigurationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalVectorSearchVectorizerClassification(rawMsg json.RawMessage) (VectorSearchVectorizerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b VectorSearchVectorizerClassification
	switch m["kind"] {
	case string(VectorSearchVectorizerKindAzureOpenAI):
		b = &AzureOpenAIVectorizer{}
	case string(VectorSearchVectorizerKindCustomWebAPI):
		b = &WebAPIVectorizer{}
	default:
		b = &VectorSearchVectorizer{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalVectorSearchVectorizerClassificationArray(rawMsg json.RawMessage) ([]VectorSearchVectorizerClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]VectorSearchVectorizerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalVectorSearchVectorizerClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

